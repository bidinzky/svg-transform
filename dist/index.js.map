{"version":3,"sources":["../src/flatten/parser.ts","../src/flatten/serialize.ts","../src/flatten/helper.ts","../src/flatten/shapeToPath.ts","../src/flatten/transformPath.ts","../src/flatten/index.ts","../src/index.ts"],"sourcesContent":["/**\n * Standalone pathData parser\n * returns a pathData array compliant\n * with the w3C SVGPathData interface draft\n * https://svgwg.org/specs/paths/#InterfaceSVGPathData\n * Usage example:\n */\n\nimport { PathData } from \"./type\";\nexport type {PathData} from \"./type\";\nexport function parsePathDataNormalized(d: string) {\n    d = d\n        // remove new lines, tabs an comma with whitespace\n        .replace(/[\\n\\r\\t|,]/g, \" \")\n        // pre trim left and right whitespace\n        .trim()\n        // add space before minus sign\n        .replace(/(\\d)-/g, \"$1 -\")\n        // decompose multiple adjacent decimal delimiters like 0.5.5.5 => 0.5 0.5 0.5\n        .replace(/(\\.)(?=(\\d+\\.\\d+)+)(\\d+)/g, \"$1$3 \");\n\n    let pathData: PathData = [];\n    let cmdRegEx = /([mlcqazvhst])([^mlcqazvhst]*)/gi;\n    let commands = d.match(cmdRegEx);\n\n    if (null === commands) {\n        return pathData;\n    }\n\n    // valid command value lengths\n    let comLengths = { m: 2, a: 7, c: 6, h: 1, l: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };\n\n    // offsets for absolute conversion\n    let offX, offY, lastX, lastY;\n\n    for (let c = 0; c < commands.length; c++) {\n        let com = commands[c];\n        let type = com.substring(0, 1);\n        let typeRel = type.toLowerCase();\n        let typeAbs = type.toUpperCase();\n        let isRel = type === typeRel;\n        let chunkSize = comLengths[typeRel];\n\n        // split values to array\n        let values: string[] | number[] = com.substring(1, com.length).trim().split(\" \").filter(Boolean);\n\n        /**\n         * A - Arc commands\n         * large arc and sweep flags\n         * are boolean and can be concatenated like\n         * 11 or 01\n         * or be concatenated with the final on path points like\n         * 1110 10 => 1 1 10 10\n         */\n        if (typeRel === \"a\" && values.length != comLengths.a) {\n            let n = 0,\n                arcValues: string[] = [];\n            for (let i = 0; i < values.length; i++) {\n                let value = values[i];\n\n                // reset counter\n                if (n >= chunkSize) {\n                    n = 0;\n                }\n                // if 3. or 4. parameter longer than 1\n                if ((n === 3 || n === 4) && value.length > 1) {\n                    let largeArc = n === 3 ? value.substring(0, 1) : \"\";\n                    let sweep = n === 3 ? value.substring(1, 2) : value.substring(0, 1);\n                    let finalX = n === 3 ? value.substring(2) : value.substring(1);\n                    let comN = [largeArc, sweep, finalX].filter(Boolean);\n                    arcValues.push(...comN);\n                    n += comN.length;\n                } else {\n                    // regular\n                    arcValues.push(value);\n                    n++;\n                }\n            }\n            values = arcValues.flat().filter(Boolean);\n        }\n\n        // string  to number\n        values = values.map(Number);\n\n        // if string contains repeated shorthand commands - split them\n        let hasMultiple = values.length > chunkSize;\n        let chunk = hasMultiple ? values.slice(0, chunkSize) : values;\n        let comChunks = [{ type: type, values: chunk }];\n\n        // has implicit or repeated commands â€“ split into chunks\n        if (hasMultiple) {\n            let typeImplicit = typeRel === \"m\" ? (isRel ? \"l\" : \"L\") : type;\n            for (let i = chunkSize; i < values.length; i += chunkSize) {\n                let chunk = values.slice(i, i + chunkSize);\n                comChunks.push({ type: typeImplicit, values: chunk });\n            }\n        }\n\n        /**\n         * convert to absolute\n         * init offset from 1st M\n         */\n        if (c === 0) {\n            offX = values[0];\n            offY = values[1];\n            lastX = offX;\n            lastY = offY;\n        }\n\n        let typeFirst = comChunks[0].type;\n        typeAbs = typeFirst.toUpperCase();\n\n        // first M is always absolute\n        isRel =\n            typeFirst.toLowerCase() === typeFirst && pathData.length ? true : false;\n\n        for (let i = 0; i < comChunks.length; i++) {\n            let com = comChunks[i];\n            let type = com.type;\n            let values = com.values;\n            let valuesL = values.length;\n            let comPrev = comChunks[i - 1]\n                ? comChunks[i - 1]\n                : c > 0 && pathData[pathData.length - 1]\n                    ? pathData[pathData.length - 1]\n                    : comChunks[i];\n\n            let valuesPrev = comPrev.values;\n            let valuesPrevL = valuesPrev.length;\n            isRel =\n                comChunks.length > 1\n                    ? type.toLowerCase() === type && pathData.length > 0\n                    : isRel;\n\n            if (isRel) {\n                com.type = comChunks.length > 1 ? type.toUpperCase() : typeAbs;\n\n                switch (typeRel) {\n                    case \"a\":\n                        com.values = [\n                            values[0],\n                            values[1],\n                            values[2],\n                            values[3],\n                            values[4],\n                            values[5] + offX,\n                            values[6] + offY\n                        ];\n                        break;\n\n                    case \"h\":\n                    case \"v\":\n                        com.values = type === \"h\" ? [values[0] + offX] : [values[0] + offY];\n                        break;\n\n                    case \"m\":\n                    case \"l\":\n                    case \"t\":\n                        com.values = [values[0] + offX, values[1] + offY];\n                        break;\n\n                    case \"c\":\n                        com.values = [\n                            values[0] + offX,\n                            values[1] + offY,\n                            values[2] + offX,\n                            values[3] + offY,\n                            values[4] + offX,\n                            values[5] + offY\n                        ];\n                        break;\n\n                    case \"q\":\n                    case \"s\":\n                        com.values = [\n                            values[0] + offX,\n                            values[1] + offY,\n                            values[2] + offX,\n                            values[3] + offY\n                        ];\n                        break;\n                }\n            }\n            // is absolute\n            else {\n                offX = 0;\n                offY = 0;\n            }\n\n            /**\n             * convert shorthands\n             */\n            let shorthandTypes = [\"H\", \"V\", \"S\", \"T\"];\n\n            if (shorthandTypes.includes(typeAbs)) {\n                let cp1X, cp1Y, cpN1X, cpN1Y, cp2X, cp2Y;\n                if (com.type === \"H\" || com.type === \"V\") {\n                    com.values =\n                        com.type === \"H\" ? [com.values[0], lastY] : [lastX, com.values[0]];\n                    com.type = \"L\";\n                } else if (com.type === \"T\" || com.type === \"S\") {\n                    [cp1X, cp1Y] = [valuesPrev[0], valuesPrev[1]];\n                    [cp2X, cp2Y] =\n                        valuesPrevL > 2\n                            ? [valuesPrev[2], valuesPrev[3]]\n                            : [valuesPrev[0], valuesPrev[1]];\n\n                    // new control point\n                    cpN1X = com.type === \"T\" ? lastX * 2 - cp1X : lastX * 2 - cp2X;\n                    cpN1Y = com.type === \"T\" ? lastY * 2 - cp1Y : lastY * 2 - cp2Y;\n\n                    com.values = [cpN1X, cpN1Y, com.values].flat();\n                    com.type = com.type === \"T\" ? \"Q\" : \"C\";\n                }\n            }\n\n            // add to pathData array\n            pathData.push(com);\n\n            // update offsets\n            lastX =\n                valuesL > 1\n                    ? values[valuesL - 2] + offX\n                    : typeRel === \"h\"\n                        ? values[0] + offX\n                        : lastX;\n            lastY =\n                valuesL > 1\n                    ? values[valuesL - 1] + offY\n                    : typeRel === \"v\"\n                        ? values[0] + offY\n                        : lastY;\n            offX = lastX;\n            offY = lastY;\n        }\n    }\n\n    /**\n     * first M is always absolute/uppercase -\n     * unless it adds relative linetos\n     * (facilitates d concatenating)\n     */\n    pathData[0].type = \"M\";\n\n    return pathData;\n}","import type { PathData } from \"./type\";\n\n/**\n * serialize pathData array to\n * d attribute string\n */\nexport function serializePathData(pathData: PathData, decimals = 3) {\n    let d = `${pathData[0].type}${pathData[0].values.map(val => { return +val.toFixed(decimals) }).join(\" \")}`;\n\n    for (let i = 1; i < pathData.length; i++) {\n        let com0 = pathData[i - 1];\n        let com = pathData[i];\n        let { type, values } = com;\n\n        // minify arctos\n        // yet another arc exception ... since they need more accuracy for rx, ry, x-rotation\n        if (type === \"a\" || type === \"A\" && decimals > -1) {\n            values = [\n                +values[0].toFixed(decimals + 1),\n                +values[1].toFixed(decimals + 1),\n                +values[2].toFixed(decimals + 1),\n                values[3],\n                values[4],\n                +values[5].toFixed(decimals),\n                +values[6].toFixed(decimals)\n            ];\n        }\n\n        // round\n        else if (values.length && decimals > -1) {\n            values = values.map((val) => {\n                return typeof val === \"number\" ? +val.toFixed(decimals) : val;\n            });\n        }\n\n        // omit type for repeated commands\n        type = com.type;\n\n        d += `${type}${values.join(\" \")}`;\n    }\n    return d;\n}\n\n","\nexport function svgElUnitsToPixel(el: SVGElement, decimals = 5) {\n    const svg = (el.nodeName !== \"svg\" ? el.closest(\"svg\") : el) as SVGSVGElement;\n\n    // convert real life units to pixels\n    const translateUnitToPixel = (value) => {\n\n        if (value === null) {\n            return 0\n        }\n        //default dpi = 96\n        let dpi = 96;\n        let unit = value.match(/([a-z]+)/gi);\n        unit = unit ? unit[0] : \"\";\n        let val = parseFloat(value);\n        let rat;\n\n        // no unit - already pixes/user unit\n        if (!unit) {\n            return val;\n        }\n\n        switch (unit) {\n            case \"in\":\n                rat = dpi;\n                break;\n            case \"pt\":\n                rat = (1 / 72) * 96;\n                break;\n            case \"cm\":\n                rat = (1 / 2.54) * 96;\n                break;\n            case \"mm\":\n                rat = ((1 / 2.54) * 96) / 10;\n                break;\n            // just a default approximation\n            case \"em\":\n                rat = 16;\n                break;\n            default:\n                rat = 1;\n        }\n        let valuePx = val * rat;\n        return +valuePx.toFixed(decimals);\n    };\n\n    // svg width and height attributes\n    const widthString = svg.getAttribute(\"width\");\n    const width = widthString ? translateUnitToPixel(widthString) : 300;\n    const heightString = svg.getAttribute(\"height\");\n    const height = widthString ? translateUnitToPixel(heightString) : 150;\n\n    //prefer viewBox values\n    const vBString = svg.getAttribute(\"viewBox\");\n    const vB = vBString\n        ? vBString\n            .replace(/,/g, \" \")\n            .split(\" \")\n            .filter(Boolean)\n            .map((val) => {\n                return +val;\n            })\n        : [];\n\n    let w = vB.length ? vB[2] : width;\n    let h = vB.length ? vB[3] : height;\n    let scaleX = 0.01 * w;\n    let scaleY = 0.01 * h;\n    let scalRoot = Math.sqrt((Math.pow(scaleX, 2) + Math.pow(scaleY, 2)) / 2);\n    let attsH = [\"x\", \"width\", \"x1\", \"x2\", \"rx\", \"cx\", \"r\"];\n    let attsV = [\"y\", \"height\", \"y1\", \"y2\", \"ry\", \"cy\"];\n\n\n    let atts = el.getAttributeNames();\n    atts.forEach((att) => {\n        let val = el.getAttribute(att);\n        let valAbs: string | number | null = val;\n        if ((attsH.includes(att) || attsV.includes(att)) && val && valAbs) {\n            let scale = attsH.includes(att) ? scaleX : scaleY;\n            scale = att === \"r\" && w != h ? scalRoot : scale;\n            if (val.includes(\"%\")) {\n                valAbs = parseFloat(val) * scale;\n            }\n            //absolute units\n            else {\n                valAbs = translateUnitToPixel(val);\n            }\n            el.setAttribute(att, valAbs.toString());\n        }\n    });\n}\n","/**\n * retrieve patData from primitives:\n * <circle>, <ellipse>, <rect>, <polygon>, <polyline>, <line>, \n */\n\nimport { svgElUnitsToPixel } from \"./helper\";\nimport { parsePathDataNormalized } from \"./parser\";\nimport { serializePathData } from \"./serialize\";\nimport { PathData } from \"./type\";\n\nexport function convertShapeToPath(el: SVGGeometryElement, decimals = 3) {\n    let pathData = getPathDataFromEl(el);\n\n    // create path element\n    let path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n\n    // get all attributes as object\n    const setAttributes = (el: SVGGeometryElement, attributes: Record<string, string>, exclude: string[] = []) => {\n        for (let key in attributes) {\n            if (exclude.indexOf(key) === -1) {\n                el.setAttribute(key, attributes[key]);\n            }\n        }\n    }\n    const getAttributes = (el: SVGGeometryElement) => {\n        let attArr = [...el.attributes];\n        let attObj: Record<string, string> = {};\n        attArr.forEach((att) => {\n            if (att.nodeValue) {\n                attObj[att.nodeName] = att.nodeValue;\n            }\n        });\n        return attObj;\n    }\n\n    let attributes = getAttributes(el);\n\n    //exclude attributes not needed for paths\n    let exclude = [\"x\", \"y\", \"x1\", \"y1\", \"x2\", \"y2\", \"cx\", \"cy\", \"r\", \"rx\", \"ry\", \"points\", \"width\", \"height\"];\n\n    // copy attributes to path and set pathData\n    setAttributes(path, attributes, exclude);\n    let d = serializePathData(pathData, decimals)\n    path.setAttribute('d', d);\n    el.replaceWith(path);\n    return path;\n}\n\n// retrieve pathdata from svg geometry elements\nexport function getPathDataFromEl(el: SVGGeometryElement) {\n    let pathData: PathData = [];\n    let type = el.nodeName;\n    let atts, attNames, d, x, y, width, height, r, rx, ry, cx, cy, x1, x2, y1, y2;\n\n    // convert relative or absolute units \n    svgElUnitsToPixel(el)\n\n    const getAtts = (attNames) => {\n        atts = {}\n        attNames.forEach(att => {\n            const attr = el.getAttribute(att);\n            if (attr) {\n                atts[att] = +attr\n            }\n        })\n        return atts\n    }\n\n    switch (type) {\n        case 'path':\n            d = el.getAttribute(\"d\");\n            pathData = parsePathDataNormalized(d);\n            break;\n\n        case 'rect':\n            attNames = ['x', 'y', 'width', 'height', 'rx', 'ry'];\n            ({ x, y, width, height, rx, ry } = getAtts(attNames));\n\n\n            if (!rx && !ry) {\n                pathData = [\n                    { type: \"M\", values: [x, y] },\n                    { type: \"H\", values: [x + width] },\n                    { type: \"V\", values: [y + height] },\n                    { type: \"H\", values: [x] },\n                    { type: \"Z\", values: [] }\n                ];\n            } else {\n\n                if (rx > width / 2) {\n                    rx = width / 2;\n                }\n                if (ry > height / 2) {\n                    ry = height / 2;\n                }\n\n                pathData = [\n                    { type: \"M\", values: [x + rx, y] },\n                    { type: \"H\", values: [x + width - rx] },\n                    { type: \"A\", values: [rx, ry, 0, 0, 1, x + width, y + ry] },\n                    { type: \"V\", values: [y + height - ry] },\n                    { type: \"A\", values: [rx, ry, 0, 0, 1, x + width - rx, y + height] },\n                    { type: \"H\", values: [x + rx] },\n                    { type: \"A\", values: [rx, ry, 0, 0, 1, x, y + height - ry] },\n                    { type: \"V\", values: [y + ry] },\n                    { type: \"A\", values: [rx, ry, 0, 0, 1, x + rx, y] },\n                    { type: \"Z\", values: [] }\n                ];\n            }\n            break;\n\n        case 'circle':\n        case 'ellipse':\n\n            attNames = ['cx', 'cy', 'rx', 'ry', 'r'];\n            ({ cx, cy, r, rx, ry } = getAtts(attNames));\n\n            if (type === 'circle') {\n                r = r;\n                rx = r\n                ry = r\n            } else {\n                rx = rx ? rx : r;\n                ry = ry ? ry : r;\n            }\n\n            pathData = [\n                { type: \"M\", values: [cx + rx, cy] },\n                { type: \"A\", values: [rx, ry, 0, 1, 1, cx - rx, cy] },\n                { type: \"A\", values: [rx, ry, 0, 1, 1, cx + rx, cy] },\n            ];\n\n            break;\n        case 'line':\n            attNames = ['x1', 'y1', 'x2', 'y2'];\n            ({ x1, y1, x2, y2 } = getAtts(attNames));\n            pathData = [\n                { type: \"M\", values: [x1, y1] },\n                { type: \"L\", values: [x2, y2] }\n            ];\n            break;\n        case 'polygon':\n        case 'polyline':\n            const attr = el.getAttribute('points');\n            if (attr) {\n                let points = attr.replaceAll(',', ' ').split(' ').filter(Boolean)\n\n                for (let i = 0; i < points.length; i += 2) {\n                    pathData.push({\n                        type: (i === 0 ? \"M\" : \"L\"),\n                        values: [+points[i], +points[i + 1]]\n                    });\n                }\n                if (type === 'polygon') {\n                    pathData.push({\n                        type: \"Z\",\n                        values: []\n                    });\n                }\n            }\n\n            break;\n    }\n\n    return pathData;\n};\n","import { Matrix, PathData, PathElement, Point } from \"./type\";\n\n/**\n * scale pathData\n */\nexport function transformPathData(pathData: PathData, matrix: Matrix) {\n    // new pathdata\n    let pathDataTrans: PathData = [];\n\n    // normalize matrix input\n    matrix = normalizeMatrix(matrix);\n\n    let matrixStr = [matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f]\n        .map((val) => {\n            return +val.toFixed(1);\n        })\n        .join(\"\");\n\n    // no transform: quit\n    if (matrixStr === \"100100\") {\n        //console.log(\"no transform\");\n        return pathData;\n    }\n\n    pathData.forEach((com, i) => {\n        let { type, values } = com;\n        let typeRel = type.toLowerCase();\n        let comPrev = i > 0 ? pathData[i - 1] : pathData[i];\n        let comPrevValues = comPrev.values;\n        let comPrevValuesL = comPrevValues.length;\n        let p0 = {\n            x: comPrevValues[comPrevValuesL - 2],\n            y: comPrevValues[comPrevValuesL - 1]\n        };\n        let p = { x: values[values.length - 2], y: values[values.length - 1] };\n        let comT: PathElement = { type: type, values: [] };\n\n        switch (typeRel) {\n            case \"a\":\n                comT = transformArc(p0, values, matrix)\n                break;\n\n            default:\n                // all other point based commands\n                if (values.length) {\n                    for (let i = 0; i < values.length; i += 2) {\n                        let ptTrans = transformPoint(\n                            { x: com.values[i], y: com.values[i + 1] },\n                            matrix\n                        );\n                        comT.values[i] = ptTrans.x;\n                        comT.values[i + 1] = ptTrans.y;\n                    }\n                }\n        }\n\n        pathDataTrans.push(comT);\n    });\n    return pathDataTrans;\n}\n\n// transform point by 2d matrix\nfunction transformPoint(pt: Point, matrix: Matrix) {\n    let { a, b, c, d, e, f } = matrix;\n    let { x, y } = pt;\n    return { x: a * x + c * y + e, y: b * x + d * y + f };\n}\n\n//normalize matrix notations object, array or css matrix string\nfunction normalizeMatrix(matrix: Matrix | string | number[]) {\n    matrix =\n        typeof matrix === \"string\"\n            ? (matrix = matrix\n                .replace(/^matrix\\(|\\)$/g, \"\")\n                .split(\",\")\n                .map(Number))\n            : matrix;\n    return !Array.isArray(matrix)\n        ? {\n            a: matrix.a,\n            b: matrix.b,\n            c: matrix.c,\n            d: matrix.d,\n            e: matrix.e,\n            f: matrix.f\n        }\n        : {\n            a: matrix[0],\n            b: matrix[1],\n            c: matrix[2],\n            d: matrix[3],\n            e: matrix[4],\n            f: matrix[5]\n        };\n}\n\n\nfunction transformArc(p0: Point, values: number[], matrix: Matrix) {\n    let [rx, ry, angle, largeArc, sweep, x, y] = values;\n\n    /**\n    * parametrize arc command \n    * to get the actual arc params\n    */\n    let arcData = svgArcToCenterParam(\n        p0.x,\n        p0.y,\n        values[0],\n        values[1],\n        angle,\n        largeArc,\n        sweep,\n        x,\n        y\n    );\n    ({ rx, ry } = arcData);\n    let { a, b, c, d, e, f } = matrix;\n\n    let ellipsetr = transformEllipse(rx, ry, angle, matrix);\n    let p = transformPoint({ x: x, y: y }, matrix);\n\n\n    // adjust sweep if flipped\n    let denom = a ** 2 + b ** 2;\n    let scaleX = Math.sqrt(denom)\n    let scaleY = (a * d - c * b) / scaleX\n\n    let flipX = scaleX < 0 ? true : false;\n    let flipY = scaleY < 0 ? true : false;\n\n\n    // adjust sweep\n    if (flipX || flipY) {\n        sweep = sweep === 0 ? 1 : 0;\n    }\n\n    return {\n        type: 'A',\n        values: [\n            ellipsetr.rx,\n            ellipsetr.ry,\n            ellipsetr.ax,\n            largeArc,\n            sweep,\n            p.x,\n            p.y]\n    };\n}\n\n/**\n * Based on: https://github.com/fontello/svgpath/blob/master/lib/ellipse.js\n * and fork: https://github.com/kpym/SVGPathy/blob/master/lib/ellipse.js\n */\n\nfunction transformEllipse(rx: number, ry: number, ax: number, matrix: Matrix) {\n    const torad = Math.PI / 180;\n    const epsilon = 1e-7;\n\n    //normalize matrix object or array notations\n    matrix = !Array.isArray(matrix)\n        ? matrix\n        : {\n            a: matrix[0],\n            b: matrix[1],\n            c: matrix[2],\n            d: matrix[3],\n            e: matrix[4],\n            f: matrix[5]\n        };\n\n    // We consider the current ellipse as image of the unit circle\n    // by first scale(rx,ry) and then rotate(ax) ...\n    // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.\n    var c = Math.cos(ax * torad),\n        s = Math.sin(ax * torad);\n    var ma = [\n        rx * (matrix.a * c + matrix.c * s),\n        rx * (matrix.b * c + matrix.d * s),\n        ry * (-matrix.a * s + matrix.c * c),\n        ry * (-matrix.b * s + matrix.d * c)\n    ];\n\n    // ma * transpose(ma) = [ J L ]\n    //                      [ L K ]\n    // L is calculated later (if the image is not a circle)\n    var J = ma[0] * ma[0] + ma[2] * ma[2],\n        K = ma[1] * ma[1] + ma[3] * ma[3];\n\n    // the sqrt of the discriminant of the characteristic polynomial of ma * transpose(ma)\n    // this is also the geometric mean of the eigenvalues\n    var D = Math.sqrt(\n        ((ma[0] - ma[3]) * (ma[0] - ma[3]) + (ma[2] + ma[1]) * (ma[2] + ma[1])) *\n        ((ma[0] + ma[3]) * (ma[0] + ma[3]) + (ma[2] - ma[1]) * (ma[2] - ma[1]))\n    );\n\n    // the arithmetic mean of the eigenvalues\n    var JK = (J + K) / 2;\n\n    // check if the image is (almost) a circle\n    if (D <= epsilon) {\n        rx = ry = Math.sqrt(JK);\n        ax = 0;\n        return { rx: rx, ry: ry, ax: ax };\n    }\n\n    // check if ma * transpose(ma) is (almost) diagonal\n    if (Math.abs(D - Math.abs(J - K)) <= epsilon) {\n        rx = Math.sqrt(J);\n        ry = Math.sqrt(K);\n        ax = 0;\n        return { rx: rx, ry: ry, ax: ax };\n    }\n\n    // if it is not a circle, nor diagonal\n    var L = ma[0] * ma[1] + ma[2] * ma[3];\n\n    // {l1,l2} = the two eigen values of ma * transpose(ma)\n    var l1 = JK + D / 2,\n        l2 = JK - D / 2;\n\n    // the x - axis - rotation angle is the argument of the l1 - eigenvector\n    if (Math.abs(L) <= epsilon && Math.abs(l1 - K) <= epsilon) {\n        // if (ax == 90) => ax = 0 and exchange axes\n        ax = 0;\n        rx = Math.sqrt(l2);\n        ry = Math.sqrt(l1);\n        return { rx: rx, ry: ry, ax: ax };\n    }\n\n    ax =\n        Math.atan(Math.abs(L) > Math.abs(l1 - K) ? (l1 - J) / L : L / (l1 - K)) /\n        torad; // the angle in degree\n\n    // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90\n    if (ax >= 0) {\n        // if ax in [0,90]\n        rx = Math.sqrt(l1);\n        ry = Math.sqrt(l2);\n    } else {\n        // if ax in ]-90,0[ => exchange axes\n        ax += 90;\n        rx = Math.sqrt(l2);\n        ry = Math.sqrt(l1);\n    }\n\n    return { rx: rx, ry: ry, ax: ax };\n}\n\n\n/**\n* based on @cuixiping;\n* https://stackoverflow.com/questions/9017100/calculate-center-of-svg-arc/12329083#12329083\n*/\nfunction svgArcToCenterParam(p0x: number, p0y: number, rx: number, ry: number, angle: number, largeArc: number, sweep: number, px: number, py: number) {\n\n    const radian = (ux, uy, vx, vy) => {\n        let dot = ux * vx + uy * vy;\n        let mod = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));\n        let rad = Math.acos(dot / mod);\n        if (ux * vy - uy * vx < 0) {\n            rad = -rad;\n        }\n        return rad;\n    };\n\n    // degree to radian: if rx===ry the angle param has no effect\n    let phi = rx === ry ? 0 : (+angle * Math.PI) / 180;\n\n    let cx, cy, startAngle, deltaAngle, endAngle;\n    let PI = Math.PI;\n    let PIpx = PI * 2;\n\n    if (rx == 0 || ry == 0) {\n        // invalid arguments\n        throw Error(\"rx and ry can not be 0\");\n    }\n\n    // ensure rx and ry are positive\n    if (rx < 0 || ry < 0) {\n        [rx, ry] = [Math.abs(rx), Math.abs(ry)]\n    }\n\n    let s_phi = phi === 0 ? 0 : Math.sin(phi);\n    let c_phi = phi === 0 ? 1 : Math.cos(phi);\n\n    let hd_x = (p0x - px) / 2; // half diff of x\n    let hd_y = (p0y - py) / 2; // half diff of y\n    let hs_x = (p0x + px) / 2; // half sum of x\n    let hs_y = (p0y + py) / 2; // half sum of y\n\n    // F6.5.1\n    let p0x_ = c_phi * hd_x + s_phi * hd_y;\n    let p0y_ = c_phi * hd_y - s_phi * hd_x;\n\n    // F.6.6 Correction of out-of-range radii\n    //   Step 3: Ensure radii are large enough\n    let lambda = (p0x_ * p0x_) / (rx * rx) + (p0y_ * p0y_) / (ry * ry);\n\n    if (lambda > 1) {\n        rx = rx * Math.sqrt(lambda);\n        ry = ry * Math.sqrt(lambda);\n    }\n\n    let rxry = rx * ry;\n    let rxp0y_ = rx * p0y_;\n    let ryp0x_ = ry * p0x_;\n    let sum_of_sq = rxp0y_ * rxp0y_ + ryp0x_ * ryp0x_; // sum of square\n    if (!sum_of_sq) {\n        throw Error(\"start point can not be same as end point\");\n    }\n\n    let coe = Math.sqrt(Math.abs((rxry * rxry - sum_of_sq) / sum_of_sq));\n\n    if (largeArc == sweep) {\n        coe = -coe;\n    }\n    // F6.5.2\n    let cx_ = (coe * rxp0y_) / ry;\n    let cy_ = (-coe * ryp0x_) / rx;\n\n    // F6.5.3\n    cx = c_phi * cx_ - s_phi * cy_ + hs_x;\n    cy = s_phi * cx_ + c_phi * cy_ + hs_y;\n    let xcr1 = (p0x_ - cx_) / rx;\n    let xcr2 = (p0x_ + cx_) / rx;\n    let ycr1 = (p0y_ - cy_) / ry;\n    let ycr2 = (p0y_ + cy_) / ry;\n\n    // F6.5.5\n    startAngle = radian(1, 0, xcr1, ycr1);\n\n    // F6.5.6\n    deltaAngle = radian(xcr1, ycr1, -xcr2, -ycr2);\n\n    if (deltaAngle > PIpx) {\n        deltaAngle -= PIpx;\n    } else if (deltaAngle < 0) {\n        deltaAngle += PIpx;\n    }\n    if (sweep == 0) {\n        deltaAngle -= PIpx;\n    }\n    endAngle = startAngle + deltaAngle;\n    if (endAngle > PIpx) {\n        endAngle -= PIpx;\n    } else if (endAngle < 0) {\n        endAngle += PIpx;\n    }\n    let toDegFactor = 180 / PI;\n    let outputObj = {\n        cx: cx,\n        cy: cy,\n        rx: rx,\n        ry: ry,\n        startAngle_deg: startAngle * toDegFactor,\n        startAngle: startAngle,\n        deltaAngle_deg: deltaAngle * toDegFactor,\n        deltaAngle: deltaAngle,\n        endAngle_deg: endAngle * toDegFactor,\n        endAngle: endAngle,\n        clockwise: sweep == 1\n    };\n\n    return outputObj;\n}","import { parsePathDataNormalized } from \"./parser\";\nimport { serializePathData } from \"./serialize\";\nimport { convertShapeToPath } from \"./shapeToPath\";\nimport { transformPathData } from \"./transformPath\";\n\ntype FlattenSvgOptions = {\n    decimals: number\n}\n\nexport function flattenSVGTransformations(svg: SVGSVGElement, options: Partial<FlattenSvgOptions>) {\n\n    options = {\n        decimals: 3,\n        ...options\n    };\n\n    let els = svg.querySelectorAll<SVGGraphicsElement>('text, path, polyline, polygon, line, rect, circle, ellipse');\n    els.forEach(el => {\n        // convert shapes to paths\n        if (el instanceof SVGGeometryElement && el.nodeName !== 'path') {\n            el = convertShapeToPath(el)\n        }\n\n        //flatten element transformations\n        reduceElementTransforms(el, options);\n    });\n    // remove group transforms\n    let groups = svg.querySelectorAll('g');\n    groups.forEach(g => {\n        g.removeAttribute('transform');\n        g.removeAttribute('transform-origin');\n        g.style.removeProperty('transform');\n        g.style.removeProperty('transform-origin');\n    });\n}\n\n\nfunction reduceElementTransforms(el: SVGGraphicsElement, options: Partial<{\n    minify: boolean;\n    decimals: number;\n}>) {\n\n    options = {\n        decimals: 3,\n        ...options\n    };\n\n\n    //decimals = 3, arcsToCubic = false, arcAccuracy = 1\n    let { decimals } = options;\n\n\n    let parent = el.viewportElement;\n    if (null === parent || !(parent instanceof SVGGraphicsElement)) {\n        return [];\n    }\n    // check elements transformations\n    let matrix = parent.getScreenCTM()!.inverse().multiply(el.getScreenCTM()!);\n    let { a, b, c, d, e, f } = matrix;\n    // round matrix\n    [a, b, c, d, e, f] = [a, b, c, d, e, f].map(val => {\n        return +val.toFixed(3)\n    });\n    let matrixStr = [a, b, c, d, e, f].join('');\n    let isTransformed = matrixStr !== \"100100\" ? true : false;\n    if (isTransformed) {\n        // matrix to readable transfomr functions\n        let transObj = qrDecomposeMatrix(matrix);\n        // scale stroke-width\n        let scale = (Math.abs(transObj.scaleX) + Math.abs(transObj.scaleY)) / 2;\n\n        scaleStrokeWidth(el, scale, decimals)\n        // if text element: consolidate all applied transforms \n        if (el instanceof SVGGeometryElement === false) {\n            if (isTransformed) {\n                if(transObj.svgTransform) {\n                    el.setAttribute('transform', transObj.svgTransform);\n                }\n                el.removeAttribute('transform-origin');\n                el.style.removeProperty('transform');\n                el.style.removeProperty('transform-origin');\n            }\n            return false\n        }\n        /**\n         * is geometry elements: \n         * recalculate pathdata\n         * according to transforms\n         * by matrix transform\n         */\n        let d = el.getAttribute(\"d\")!;\n        let pathData = parsePathDataNormalized(d);\n\n        pathData = transformPathData(pathData, matrix)\n\n        // apply pathdata - remove transform\n        let dNew = serializePathData(pathData, decimals)\n        el.setAttribute('d', dNew);\n        el.removeAttribute('transform');\n        el.style.removeProperty('transform');\n        return pathData;\n    }\n}\n\n\nfunction scaleStrokeWidth(el: SVGElement, scale: number, decimals = 3) {\n    let styles = window.getComputedStyle(el);\n    let strokeWidth: string | number = styles.getPropertyValue('stroke-width');\n    let stroke = styles.getPropertyValue('stroke');\n    strokeWidth = stroke != 'none' ? Math.abs(parseFloat(strokeWidth) * scale) : 0;\n\n    // exclude text elements, since they remain transformed\n    if (strokeWidth && el.nodeName.toLowerCase() !== 'text') {\n        el.setAttribute('stroke-width', strokeWidth.toFixed(decimals + 2));\n        el.style.removeProperty('stroke-width');\n    }\n}\n\n\n/**\n *  Decompose matrix to readable transform properties \n *  translate() rotate() scale() etc.\n *  based on @AndreaBogazzi's answer\n *  https://stackoverflow.com/questions/5107134/find-the-rotation-and-skew-of-a-matrix-transformation#32125700\n *  return object with seperate transform properties \n *  and ready to use css or svg attribute strings\n */\nfunction qrDecomposeMatrix(matrix: SVGMatrix, precision = 3) {\n    let { a, b, c, d, e, f } = matrix;\n    // matrix is array\n    if (Array.isArray(matrix)) {\n        [a, b, c, d, e, f] = matrix;\n    }\n    let angle = Math.atan2(b, a),\n        denom = Math.pow(a, 2) + Math.pow(b, 2),\n        scaleX = Math.sqrt(denom),\n        scaleY = (a * d - c * b) / scaleX,\n        skewX = Math.atan2(a * c + b * d, denom) / (Math.PI / 180),\n        translateX = e ? e : 0,\n        translateY = f ? f : 0,\n        rotate = angle ? angle / (Math.PI / 180) : 0;\n    let transObj: {\n        translateX: number;\n        translateY: number;\n        rotate: number;\n        scaleX: number;\n        scaleY: number;\n        skewX: number;\n        skewY: number;\n        cssTransform?: string;\n        svgTransform?: string;\n    } = {\n        translateX: translateX,\n        translateY: translateY,\n        rotate: rotate,\n        scaleX: scaleX,\n        scaleY: scaleY,\n        skewX: skewX,\n        skewY: 0,\n    };\n    let cssTransforms: string[] = [];\n    let svgTransforms: string[] = [];\n    for (let prop in transObj) {\n        transObj[prop] = +parseFloat(transObj[prop]).toFixed(precision);\n        let val = transObj[prop];\n        let unit = \"\";\n        if (prop == \"rotate\" || prop == \"skewX\") {\n            unit = \"deg\";\n        }\n        if (prop.indexOf(\"translate\") != -1) {\n            unit = \"px\";\n        }\n        // combine these properties\n        let convert = [\"scaleX\", \"scaleY\", \"translateX\", \"translateY\"];\n        if (val !== 0) {\n            cssTransforms.push(`${prop}(${val}${unit})`);\n        }\n        if (convert.indexOf(prop) == -1 && val !== 0) {\n            svgTransforms.push(`${prop}(${val})`);\n        } else if (prop == \"scaleX\") {\n            svgTransforms.push(\n                `scale(${+scaleX.toFixed(precision)} ${+scaleY.toFixed(precision)})`\n            );\n        } else if (prop == \"translateX\") {\n            svgTransforms.push(\n                `translate(${transObj.translateX} ${transObj.translateY})`\n            );\n        }\n    }\n    // append css style string to object\n    transObj.cssTransform = cssTransforms.join(\" \");\n    transObj.svgTransform = svgTransforms.join(\" \");\n    return transObj;\n}\n\n\n","import { flattenSVGTransformations } from \"./flatten/index\";\nimport { parsePathDataNormalized, PathData } from \"./flatten/parser\";\nimport { serializePathData } from \"./flatten/serialize\";\n\nexport function SvgToPath(svg: SVGSVGElement) {\n    const copy = svg.cloneNode(true) as SVGSVGElement;\n    flattenSVGTransformations(copy, {});\n    let walker = document.createTreeWalker(copy, NodeFilter.SHOW_ELEMENT);\n\n    let node: SVGGraphicsElement | null = null;\n    let result = \"\";\n    while ((node = walker.nextNode() as SVGGraphicsElement | null)) {\n        if (!node) {\n            continue;\n        }\n\n        if (node instanceof SVGGeometryElement) {\n            let d = node.getAttribute(\"d\");\n            if(d) {\n                let path = parsePathDataNormalized(d);\n                const nonMoveIndex = path.findIndex(e => e.type !== \"M\" && e.type !== \"m\");\n                const values = getEndPos(path.slice(0,nonMoveIndex));\n                path = path.map(e => {\n                    if(e.type === \"Z\" || e.type === \"z\") {\n                        return {\n                            type: \"L\",\n                            values\n                        }\n                    }\n                    return e;\n                });\n                d = serializePathData(path);\n                result += d;\n            }\n        }\n    }\n    return result;\n}\n\nfunction getEndPos(data: PathData, pose = [0,0]) {\n    \n    for(let d of data) {\n        const current = [0,0]\n        switch(d.type.toLowerCase()) {\n            case \"v\":\n                current[1] = d.values[0];\n                break;\n            case \"h\":\n                current[0] = d.values[0];\n                break;\n            default:\n                current[0] = d.values.at(-2) ?? 0;\n                current[1] = d.values.at(-1) ?? 0;\n        }\n\n        if(d.type.toLowerCase() === d.type) {\n            current[0] += pose[0];\n            current[1] += pose[1];\n        }\n        pose[0] = current[0];\n        pose[1] = current[1];\n    }\n    return pose;\n}\nglobalThis[\"SvgToPath\"] = SvgToPath;\nexport default SvgToPath;"],"mappings":"AAUO,SAASA,EAAwBC,EAAW,CAC/CA,EAAIA,EAEC,QAAQ,cAAe,GAAG,EAE1B,KAAK,EAEL,QAAQ,SAAU,MAAM,EAExB,QAAQ,4BAA6B,OAAO,EAEjD,IAAIC,EAAqB,CAAC,EACtBC,EAAW,mCACXC,EAAWH,EAAE,MAAME,CAAQ,EAE/B,GAAaC,IAAT,KACA,OAAOF,EAIX,IAAIG,EAAa,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAE,EAG1EC,EAAMC,EAAMC,EAAOC,EAEvB,QAASC,EAAI,EAAGA,EAAIN,EAAS,OAAQM,IAAK,CACtC,IAAIC,EAAMP,EAASM,CAAC,EAChBE,EAAOD,EAAI,UAAU,EAAG,CAAC,EACzBE,EAAUD,EAAK,YAAY,EAC3BE,EAAUF,EAAK,YAAY,EAC3BG,EAAQH,IAASC,EACjBG,EAAYX,EAAWQ,CAAO,EAG9BI,EAA8BN,EAAI,UAAU,EAAGA,EAAI,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,EAAE,OAAO,OAAO,EAU/F,GAAIE,IAAY,KAAOI,EAAO,QAAUZ,EAAW,EAAG,CAClD,IAAIa,EAAI,EACJC,EAAsB,CAAC,EAC3B,QAASC,EAAI,EAAGA,EAAIH,EAAO,OAAQG,IAAK,CACpC,IAAIC,EAAQJ,EAAOG,CAAC,EAOpB,GAJIF,GAAKF,IACLE,EAAI,IAGHA,IAAM,GAAKA,IAAM,IAAMG,EAAM,OAAS,EAAG,CAC1C,IAAIC,EAAWJ,IAAM,EAAIG,EAAM,UAAU,EAAG,CAAC,EAAI,GAC7CE,EAAQL,IAAM,EAAIG,EAAM,UAAU,EAAG,CAAC,EAAIA,EAAM,UAAU,EAAG,CAAC,EAC9DG,EAASN,IAAM,EAAIG,EAAM,UAAU,CAAC,EAAIA,EAAM,UAAU,CAAC,EACzDI,EAAO,CAACH,EAAUC,EAAOC,CAAM,EAAE,OAAO,OAAO,EACnDL,EAAU,KAAK,GAAGM,CAAI,EACtBP,GAAKO,EAAK,MACd,MAEIN,EAAU,KAAKE,CAAK,EACpBH,GAER,CACAD,EAASE,EAAU,KAAK,EAAE,OAAO,OAAO,CAC5C,CAGAF,EAASA,EAAO,IAAI,MAAM,EAG1B,IAAIS,EAAcT,EAAO,OAASD,EAC9BW,EAAQD,EAAcT,EAAO,MAAM,EAAGD,CAAS,EAAIC,EACnDW,EAAY,CAAC,CAAE,KAAMhB,EAAM,OAAQe,CAAM,CAAC,EAG9C,GAAID,EAAa,CACb,IAAIG,EAAehB,IAAY,IAAOE,EAAQ,IAAM,IAAOH,EAC3D,QAAS,EAAII,EAAW,EAAIC,EAAO,OAAQ,GAAKD,EAAW,CACvD,IAAIW,EAAQV,EAAO,MAAM,EAAG,EAAID,CAAS,EACzCY,EAAU,KAAK,CAAE,KAAMC,EAAc,OAAQF,CAAM,CAAC,CACxD,CACJ,CAMIjB,IAAM,IACNJ,EAAOW,EAAO,CAAC,EACfV,EAAOU,EAAO,CAAC,EACfT,EAAQF,EACRG,EAAQF,GAGZ,IAAIuB,EAAYF,EAAU,CAAC,EAAE,KAC7Bd,EAAUgB,EAAU,YAAY,EAGhCf,EACI,GAAAe,EAAU,YAAY,IAAMA,GAAa5B,EAAS,QAEtD,QAASkB,EAAI,EAAGA,EAAIQ,EAAU,OAAQR,IAAK,CACvC,IAAIT,EAAMiB,EAAUR,CAAC,EACjBR,EAAOD,EAAI,KACXM,EAASN,EAAI,OACboB,EAAUd,EAAO,OAOjBe,GANUJ,EAAUR,EAAI,CAAC,EACvBQ,EAAUR,EAAI,CAAC,EACfV,EAAI,GAAKR,EAASA,EAAS,OAAS,CAAC,EACjCA,EAASA,EAAS,OAAS,CAAC,EAC5B0B,EAAUR,CAAC,GAEI,OACrBa,EAAcD,EAAW,OAM7B,GALAjB,EACIa,EAAU,OAAS,EACbhB,EAAK,YAAY,IAAMA,GAAQV,EAAS,OAAS,EACjDa,EAENA,EAGA,OAFAJ,EAAI,KAAOiB,EAAU,OAAS,EAAIhB,EAAK,YAAY,EAAIE,EAE/CD,EAAS,CACb,IAAK,IACDF,EAAI,OAAS,CACTM,EAAO,CAAC,EACRA,EAAO,CAAC,EACRA,EAAO,CAAC,EACRA,EAAO,CAAC,EACRA,EAAO,CAAC,EACRA,EAAO,CAAC,EAAIX,EACZW,EAAO,CAAC,EAAIV,CAChB,EACA,MAEJ,IAAK,IACL,IAAK,IACDI,EAAI,OAASC,IAAS,IAAM,CAACK,EAAO,CAAC,EAAIX,CAAI,EAAI,CAACW,EAAO,CAAC,EAAIV,CAAI,EAClE,MAEJ,IAAK,IACL,IAAK,IACL,IAAK,IACDI,EAAI,OAAS,CAACM,EAAO,CAAC,EAAIX,EAAMW,EAAO,CAAC,EAAIV,CAAI,EAChD,MAEJ,IAAK,IACDI,EAAI,OAAS,CACTM,EAAO,CAAC,EAAIX,EACZW,EAAO,CAAC,EAAIV,EACZU,EAAO,CAAC,EAAIX,EACZW,EAAO,CAAC,EAAIV,EACZU,EAAO,CAAC,EAAIX,EACZW,EAAO,CAAC,EAAIV,CAChB,EACA,MAEJ,IAAK,IACL,IAAK,IACDI,EAAI,OAAS,CACTM,EAAO,CAAC,EAAIX,EACZW,EAAO,CAAC,EAAIV,EACZU,EAAO,CAAC,EAAIX,EACZW,EAAO,CAAC,EAAIV,CAChB,EACA,KACR,MAIAD,EAAO,EACPC,EAAO,EAQX,GAFqB,CAAC,IAAK,IAAK,IAAK,GAAG,EAErB,SAASO,CAAO,EAAG,CAClC,IAAIoB,EAAMC,EAAMC,EAAOC,EAAOC,EAAMC,EAChC5B,EAAI,OAAS,KAAOA,EAAI,OAAS,KACjCA,EAAI,OACAA,EAAI,OAAS,IAAM,CAACA,EAAI,OAAO,CAAC,EAAGF,CAAK,EAAI,CAACD,EAAOG,EAAI,OAAO,CAAC,CAAC,EACrEA,EAAI,KAAO,MACJA,EAAI,OAAS,KAAOA,EAAI,OAAS,OACxC,CAACuB,EAAMC,CAAI,EAAI,CAACH,EAAW,CAAC,EAAGA,EAAW,CAAC,CAAC,EAC5C,CAACM,EAAMC,CAAI,EACPN,EAAc,EACR,CAACD,EAAW,CAAC,EAAGA,EAAW,CAAC,CAAC,EAC7B,CAACA,EAAW,CAAC,EAAGA,EAAW,CAAC,CAAC,EAGvCI,EAAQzB,EAAI,OAAS,IAAMH,EAAQ,EAAI0B,EAAO1B,EAAQ,EAAI8B,EAC1DD,EAAQ1B,EAAI,OAAS,IAAMF,EAAQ,EAAI0B,EAAO1B,EAAQ,EAAI8B,EAE1D5B,EAAI,OAAS,CAACyB,EAAOC,EAAO1B,EAAI,MAAM,EAAE,KAAK,EAC7CA,EAAI,KAAOA,EAAI,OAAS,IAAM,IAAM,IAE5C,CAGAT,EAAS,KAAKS,CAAG,EAGjBH,EACIuB,EAAU,EACJd,EAAOc,EAAU,CAAC,EAAIzB,EACtBO,IAAY,IACRI,EAAO,CAAC,EAAIX,EACZE,EACdC,EACIsB,EAAU,EACJd,EAAOc,EAAU,CAAC,EAAIxB,EACtBM,IAAY,IACRI,EAAO,CAAC,EAAIV,EACZE,EACdH,EAAOE,EACPD,EAAOE,CACX,CACJ,CAOA,OAAAP,EAAS,CAAC,EAAE,KAAO,IAEZA,CACX,CC/OO,SAASsC,EAAkBC,EAAoBC,EAAW,EAAG,CAChE,IAAIC,EAAI,GAAGF,EAAS,CAAC,EAAE,IAAI,GAAGA,EAAS,CAAC,EAAE,OAAO,IAAIG,GAAgB,CAACA,EAAI,QAAQF,CAAQ,CAAG,EAAE,KAAK,GAAG,CAAC,GAExG,QAASG,EAAI,EAAGA,EAAIJ,EAAS,OAAQI,IAAK,CACtC,IAAIC,EAAOL,EAASI,EAAI,CAAC,EACrBE,EAAMN,EAASI,CAAC,EAChB,CAAE,KAAAG,EAAM,OAAAC,CAAO,EAAIF,EAInBC,IAAS,KAAOA,IAAS,KAAON,EAAW,GAC3CO,EAAS,CACL,CAACA,EAAO,CAAC,EAAE,QAAQP,EAAW,CAAC,EAC/B,CAACO,EAAO,CAAC,EAAE,QAAQP,EAAW,CAAC,EAC/B,CAACO,EAAO,CAAC,EAAE,QAAQP,EAAW,CAAC,EAC/BO,EAAO,CAAC,EACRA,EAAO,CAAC,EACR,CAACA,EAAO,CAAC,EAAE,QAAQP,CAAQ,EAC3B,CAACO,EAAO,CAAC,EAAE,QAAQP,CAAQ,CAC/B,EAIKO,EAAO,QAAUP,EAAW,KACjCO,EAASA,EAAO,IAAKL,GACV,OAAOA,GAAQ,SAAW,CAACA,EAAI,QAAQF,CAAQ,EAAIE,CAC7D,GAILI,EAAOD,EAAI,KAEXJ,GAAK,GAAGK,CAAI,GAAGC,EAAO,KAAK,GAAG,CAAC,EACnC,CACA,OAAON,CACX,CCxCO,SAASO,EAAkBC,EAAgBC,EAAW,EAAG,CAC5D,IAAMC,EAAOF,EAAG,WAAa,MAAQA,EAAG,QAAQ,KAAK,EAAIA,EAGnDG,EAAwBC,GAAU,CAEpC,GAAIA,IAAU,KACV,MAAO,GAGX,IAAIC,EAAM,GACNC,EAAOF,EAAM,MAAM,YAAY,EACnCE,EAAOA,EAAOA,EAAK,CAAC,EAAI,GACxB,IAAIC,EAAM,WAAWH,CAAK,EACtBI,EAGJ,GAAI,CAACF,EACD,OAAOC,EAGX,OAAQD,EAAM,CACV,IAAK,KACDE,EAAMH,EACN,MACJ,IAAK,KACDG,EAAO,EAAI,GAAM,GACjB,MACJ,IAAK,KACDA,EAAO,EAAI,KAAQ,GACnB,MACJ,IAAK,KACDA,EAAQ,EAAI,KAAQ,GAAM,GAC1B,MAEJ,IAAK,KACDA,EAAM,GACN,MACJ,QACIA,EAAM,CACd,CAEA,MAAO,EADOD,EAAMC,GACJ,QAAQP,CAAQ,CACpC,EAGMQ,EAAcP,EAAI,aAAa,OAAO,EACtCQ,EAAQD,EAAcN,EAAqBM,CAAW,EAAI,IAC1DE,EAAeT,EAAI,aAAa,QAAQ,EACxCU,EAASH,EAAcN,EAAqBQ,CAAY,EAAI,IAG5DE,EAAWX,EAAI,aAAa,SAAS,EACrCY,EAAKD,EACLA,EACG,QAAQ,KAAM,GAAG,EACjB,MAAM,GAAG,EACT,OAAO,OAAO,EACd,IAAKN,GACK,CAACA,CACX,EACH,CAAC,EAEHQ,EAAID,EAAG,OAASA,EAAG,CAAC,EAAIJ,EACxBM,EAAIF,EAAG,OAASA,EAAG,CAAC,EAAIF,EACxBK,EAAS,IAAOF,EAChBG,EAAS,IAAOF,EAChBG,EAAW,KAAK,MAAM,KAAK,IAAIF,EAAQ,CAAC,EAAI,KAAK,IAAIC,EAAQ,CAAC,GAAK,CAAC,EACpEE,EAAQ,CAAC,IAAK,QAAS,KAAM,KAAM,KAAM,KAAM,GAAG,EAClDC,EAAQ,CAAC,IAAK,SAAU,KAAM,KAAM,KAAM,IAAI,EAGvCrB,EAAG,kBAAkB,EAC3B,QAASsB,GAAQ,CAClB,IAAIf,EAAMP,EAAG,aAAasB,CAAG,EACzBC,EAAiChB,EACrC,IAAKa,EAAM,SAASE,CAAG,GAAKD,EAAM,SAASC,CAAG,IAAMf,GAAOgB,EAAQ,CAC/D,IAAIC,EAAQJ,EAAM,SAASE,CAAG,EAAIL,EAASC,EAC3CM,EAAQF,IAAQ,KAAOP,GAAKC,EAAIG,EAAWK,EACvCjB,EAAI,SAAS,GAAG,EAChBgB,EAAS,WAAWhB,CAAG,EAAIiB,EAI3BD,EAASpB,EAAqBI,CAAG,EAErCP,EAAG,aAAasB,EAAKC,EAAO,SAAS,CAAC,CAC1C,CACJ,CAAC,CACL,CChFO,SAASE,EAAmBC,EAAwBC,EAAW,EAAG,CACrE,IAAIC,EAAWC,GAAkBH,CAAE,EAG/BI,EAAO,SAAS,gBAAgB,6BAA8B,MAAM,EAGlEC,EAAgB,CAACL,EAAwBM,EAAoCC,EAAoB,CAAC,IAAM,CAC1G,QAASC,KAAOF,EACRC,EAAQ,QAAQC,CAAG,IAAM,IACzBR,EAAG,aAAaQ,EAAKF,EAAWE,CAAG,CAAC,CAGhD,EAYIF,GAXmBN,GAA2B,CAC9C,IAAIS,EAAS,CAAC,GAAGT,EAAG,UAAU,EAC1BU,EAAiC,CAAC,EACtC,OAAAD,EAAO,QAASE,GAAQ,CAChBA,EAAI,YACJD,EAAOC,EAAI,QAAQ,EAAIA,EAAI,UAEnC,CAAC,EACMD,CACX,GAE+BV,CAAE,EAMjCK,EAAcD,EAAME,EAHN,CAAC,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAK,KAAM,KAAM,SAAU,QAAS,QAAQ,CAGlE,EACvC,IAAIM,EAAIC,EAAkBX,EAAUD,CAAQ,EAC5C,OAAAG,EAAK,aAAa,IAAKQ,CAAC,EACxBZ,EAAG,YAAYI,CAAI,EACZA,CACX,CAGO,SAASD,GAAkBH,EAAwB,CACtD,IAAIE,EAAqB,CAAC,EACtBY,EAAOd,EAAG,SACVe,EAAMC,EAAUJ,EAAGK,EAAGC,EAAGC,EAAOC,EAAQC,EAAGC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAG3EC,EAAkB9B,CAAE,EAEpB,IAAM+B,EAAWf,IACbD,EAAO,CAAC,EACRC,EAAS,QAAQL,GAAO,CACpB,IAAMqB,EAAOhC,EAAG,aAAaW,CAAG,EAC5BqB,IACAjB,EAAKJ,CAAG,EAAI,CAACqB,EAErB,CAAC,EACMjB,GAGX,OAAQD,EAAM,CACV,IAAK,OACDF,EAAIZ,EAAG,aAAa,GAAG,EACvBE,EAAW+B,EAAwBrB,CAAC,EACpC,MAEJ,IAAK,OACDI,EAAW,CAAC,IAAK,IAAK,QAAS,SAAU,KAAM,IAAI,EAClD,CAAE,EAAAC,EAAG,EAAAC,EAAG,MAAAC,EAAO,OAAAC,EAAQ,GAAAE,EAAI,GAAAC,CAAG,EAAIQ,EAAQf,CAAQ,EAG/C,CAACM,GAAM,CAACC,EACRrB,EAAW,CACP,CAAE,KAAM,IAAK,OAAQ,CAACe,EAAGC,CAAC,CAAE,EAC5B,CAAE,KAAM,IAAK,OAAQ,CAACD,EAAIE,CAAK,CAAE,EACjC,CAAE,KAAM,IAAK,OAAQ,CAACD,EAAIE,CAAM,CAAE,EAClC,CAAE,KAAM,IAAK,OAAQ,CAACH,CAAC,CAAE,EACzB,CAAE,KAAM,IAAK,OAAQ,CAAC,CAAE,CAC5B,GAGIK,EAAKH,EAAQ,IACbG,EAAKH,EAAQ,GAEbI,EAAKH,EAAS,IACdG,EAAKH,EAAS,GAGlBlB,EAAW,CACP,CAAE,KAAM,IAAK,OAAQ,CAACe,EAAIK,EAAIJ,CAAC,CAAE,EACjC,CAAE,KAAM,IAAK,OAAQ,CAACD,EAAIE,EAAQG,CAAE,CAAE,EACtC,CAAE,KAAM,IAAK,OAAQ,CAACA,EAAIC,EAAI,EAAG,EAAG,EAAGN,EAAIE,EAAOD,EAAIK,CAAE,CAAE,EAC1D,CAAE,KAAM,IAAK,OAAQ,CAACL,EAAIE,EAASG,CAAE,CAAE,EACvC,CAAE,KAAM,IAAK,OAAQ,CAACD,EAAIC,EAAI,EAAG,EAAG,EAAGN,EAAIE,EAAQG,EAAIJ,EAAIE,CAAM,CAAE,EACnE,CAAE,KAAM,IAAK,OAAQ,CAACH,EAAIK,CAAE,CAAE,EAC9B,CAAE,KAAM,IAAK,OAAQ,CAACA,EAAIC,EAAI,EAAG,EAAG,EAAGN,EAAGC,EAAIE,EAASG,CAAE,CAAE,EAC3D,CAAE,KAAM,IAAK,OAAQ,CAACL,EAAIK,CAAE,CAAE,EAC9B,CAAE,KAAM,IAAK,OAAQ,CAACD,EAAIC,EAAI,EAAG,EAAG,EAAGN,EAAIK,EAAIJ,CAAC,CAAE,EAClD,CAAE,KAAM,IAAK,OAAQ,CAAC,CAAE,CAC5B,GAEJ,MAEJ,IAAK,SACL,IAAK,UAEDF,EAAW,CAAC,KAAM,KAAM,KAAM,KAAM,GAAG,EACtC,CAAE,GAAAQ,EAAI,GAAAC,EAAI,EAAAJ,EAAG,GAAAC,EAAI,GAAAC,CAAG,EAAIQ,EAAQf,CAAQ,EAErCF,IAAS,UACTO,EAAIA,EACJC,EAAKD,EACLE,EAAKF,IAELC,EAAKA,GAAUD,EACfE,EAAKA,GAAUF,GAGnBnB,EAAW,CACP,CAAE,KAAM,IAAK,OAAQ,CAACsB,EAAKF,EAAIG,CAAE,CAAE,EACnC,CAAE,KAAM,IAAK,OAAQ,CAACH,EAAIC,EAAI,EAAG,EAAG,EAAGC,EAAKF,EAAIG,CAAE,CAAE,EACpD,CAAE,KAAM,IAAK,OAAQ,CAACH,EAAIC,EAAI,EAAG,EAAG,EAAGC,EAAKF,EAAIG,CAAE,CAAE,CACxD,EAEA,MACJ,IAAK,OACDT,EAAW,CAAC,KAAM,KAAM,KAAM,IAAI,EACjC,CAAE,GAAAU,EAAI,GAAAE,EAAI,GAAAD,EAAI,GAAAE,CAAG,EAAIE,EAAQf,CAAQ,EACtCd,EAAW,CACP,CAAE,KAAM,IAAK,OAAQ,CAACwB,EAAIE,CAAE,CAAE,EAC9B,CAAE,KAAM,IAAK,OAAQ,CAACD,EAAIE,CAAE,CAAE,CAClC,EACA,MACJ,IAAK,UACL,IAAK,WACD,IAAMG,EAAOhC,EAAG,aAAa,QAAQ,EACrC,GAAIgC,EAAM,CACN,IAAIE,EAASF,EAAK,WAAW,IAAK,GAAG,EAAE,MAAM,GAAG,EAAE,OAAO,OAAO,EAEhE,QAAS,EAAI,EAAG,EAAIE,EAAO,OAAQ,GAAK,EACpChC,EAAS,KAAK,CACV,KAAO,IAAM,EAAI,IAAM,IACvB,OAAQ,CAAC,CAACgC,EAAO,CAAC,EAAG,CAACA,EAAO,EAAI,CAAC,CAAC,CACvC,CAAC,EAEDpB,IAAS,WACTZ,EAAS,KAAK,CACV,KAAM,IACN,OAAQ,CAAC,CACb,CAAC,CAET,CAEA,KACR,CAEA,OAAOA,CACX,CChKO,SAASiC,EAAkBC,EAAoBC,EAAgB,CAElE,IAAIC,EAA0B,CAAC,EAY/B,OATAD,EAASE,GAAgBF,CAAM,EAEf,CAACA,EAAO,EAAGA,EAAO,EAAGA,EAAO,EAAGA,EAAO,EAAGA,EAAO,EAAGA,EAAO,CAAC,EACtE,IAAKG,GACK,CAACA,EAAI,QAAQ,CAAC,CACxB,EACA,KAAK,EAAE,IAGM,SAEPJ,GAGXA,EAAS,QAAQ,CAACK,EAAKC,IAAM,CACzB,GAAI,CAAE,KAAAC,EAAM,OAAAC,CAAO,EAAIH,EACnBI,EAAUF,EAAK,YAAY,EAE3BG,GADUJ,EAAI,EAAIN,EAASM,EAAI,CAAC,EAAIN,EAASM,CAAC,GACtB,OACxBK,EAAiBD,EAAc,OAC/BE,EAAK,CACL,EAAGF,EAAcC,EAAiB,CAAC,EACnC,EAAGD,EAAcC,EAAiB,CAAC,CACvC,EACIE,EAAI,CAAE,EAAGL,EAAOA,EAAO,OAAS,CAAC,EAAG,EAAGA,EAAOA,EAAO,OAAS,CAAC,CAAE,EACjEM,EAAoB,CAAE,KAAMP,EAAM,OAAQ,CAAC,CAAE,EAEjD,OAAQE,EAAS,CACb,IAAK,IACDK,EAAOC,GAAaH,EAAIJ,EAAQP,CAAM,EACtC,MAEJ,QAEI,GAAIO,EAAO,OACP,QAASF,EAAI,EAAGA,EAAIE,EAAO,OAAQF,GAAK,EAAG,CACvC,IAAIU,EAAUC,EACV,CAAE,EAAGZ,EAAI,OAAOC,CAAC,EAAG,EAAGD,EAAI,OAAOC,EAAI,CAAC,CAAE,EACzCL,CACJ,EACAa,EAAK,OAAOR,CAAC,EAAIU,EAAQ,EACzBF,EAAK,OAAOR,EAAI,CAAC,EAAIU,EAAQ,CACjC,CAEZ,CAEAd,EAAc,KAAKY,CAAI,CAC3B,CAAC,EACMZ,EACX,CAGA,SAASe,EAAeC,EAAWjB,EAAgB,CAC/C,GAAI,CAAE,EAAAkB,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAE,EAAIvB,EACvB,CAAE,EAAAwB,EAAG,EAAAC,CAAE,EAAIR,EACf,MAAO,CAAE,EAAGC,EAAIM,EAAIJ,EAAIK,EAAIH,EAAG,EAAGH,EAAIK,EAAIH,EAAII,EAAIF,CAAE,CACxD,CAGA,SAASrB,GAAgBF,EAAoC,CACzD,OAAAA,EACI,OAAOA,GAAW,SACXA,EAASA,EACP,QAAQ,iBAAkB,EAAE,EAC5B,MAAM,GAAG,EACT,IAAI,MAAM,EACbA,EACF,MAAM,QAAQA,CAAM,EAStB,CACE,EAAGA,EAAO,CAAC,EACX,EAAGA,EAAO,CAAC,EACX,EAAGA,EAAO,CAAC,EACX,EAAGA,EAAO,CAAC,EACX,EAAGA,EAAO,CAAC,EACX,EAAGA,EAAO,CAAC,CACf,EAfE,CACE,EAAGA,EAAO,EACV,EAAGA,EAAO,EACV,EAAGA,EAAO,EACV,EAAGA,EAAO,EACV,EAAGA,EAAO,EACV,EAAGA,EAAO,CACd,CASR,CAGA,SAASc,GAAaH,EAAWJ,EAAkBP,EAAgB,CAC/D,GAAI,CAAC0B,EAAIC,EAAIC,EAAOC,EAAUC,EAAON,EAAGC,CAAC,EAAIlB,GAiB5C,CAAE,GAAAmB,EAAI,GAAAC,CAAG,EAXII,GACVpB,EAAG,EACHA,EAAG,EACHJ,EAAO,CAAC,EACRA,EAAO,CAAC,EACRqB,EACAC,EACAC,EACAN,EACAC,CACJ,GAEA,GAAI,CAAE,EAAAP,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAE,EAAIvB,EAEvBgC,EAAYC,GAAiBP,EAAIC,EAAIC,EAAO5B,CAAM,EAClDY,EAAII,EAAe,CAAE,EAAGQ,EAAG,EAAGC,CAAE,EAAGzB,CAAM,EAIzCkC,EAAQhB,GAAK,EAAIC,GAAK,EACtBgB,EAAS,KAAK,KAAKD,CAAK,EACxBE,GAAUlB,EAAIG,EAAID,EAAID,GAAKgB,EAE3BE,EAAQF,EAAS,EACjBG,EAAQF,EAAS,EAIrB,OAAIC,GAASC,KACTR,EAAQA,IAAU,EAAI,EAAI,GAGvB,CACH,KAAM,IACN,OAAQ,CACJE,EAAU,GACVA,EAAU,GACVA,EAAU,GACVH,EACAC,EACAlB,EAAE,EACFA,EAAE,CAAC,CACX,CACJ,CAOA,SAASqB,GAAiBP,EAAYC,EAAYY,EAAYvC,EAAgB,CAC1E,IAAMwC,EAAQ,KAAK,GAAK,IAClBC,EAAU,KAGhBzC,EAAU,MAAM,QAAQA,CAAM,EAExB,CACE,EAAGA,EAAO,CAAC,EACX,EAAGA,EAAO,CAAC,EACX,EAAGA,EAAO,CAAC,EACX,EAAGA,EAAO,CAAC,EACX,EAAGA,EAAO,CAAC,EACX,EAAGA,EAAO,CAAC,CACf,EAREA,EAaN,IAAIoB,EAAI,KAAK,IAAImB,EAAKC,CAAK,EACvB,EAAI,KAAK,IAAID,EAAKC,CAAK,EACvBE,EAAK,CACLhB,GAAM1B,EAAO,EAAIoB,EAAIpB,EAAO,EAAI,GAChC0B,GAAM1B,EAAO,EAAIoB,EAAIpB,EAAO,EAAI,GAChC2B,GAAM,CAAC3B,EAAO,EAAI,EAAIA,EAAO,EAAIoB,GACjCO,GAAM,CAAC3B,EAAO,EAAI,EAAIA,EAAO,EAAIoB,EACrC,EAKIuB,EAAID,EAAG,CAAC,EAAIA,EAAG,CAAC,EAAIA,EAAG,CAAC,EAAIA,EAAG,CAAC,EAChCE,EAAIF,EAAG,CAAC,EAAIA,EAAG,CAAC,EAAIA,EAAG,CAAC,EAAIA,EAAG,CAAC,EAIhCG,EAAI,KAAK,OACPH,EAAG,CAAC,EAAIA,EAAG,CAAC,IAAMA,EAAG,CAAC,EAAIA,EAAG,CAAC,IAAMA,EAAG,CAAC,EAAIA,EAAG,CAAC,IAAMA,EAAG,CAAC,EAAIA,EAAG,CAAC,MAClEA,EAAG,CAAC,EAAIA,EAAG,CAAC,IAAMA,EAAG,CAAC,EAAIA,EAAG,CAAC,IAAMA,EAAG,CAAC,EAAIA,EAAG,CAAC,IAAMA,EAAG,CAAC,EAAIA,EAAG,CAAC,GACxE,EAGII,GAAMH,EAAIC,GAAK,EAGnB,GAAIC,GAAKJ,EACL,OAAAf,EAAKC,EAAK,KAAK,KAAKmB,CAAE,EACtBP,EAAK,EACE,CAAE,GAAIb,EAAI,GAAIC,EAAI,GAAIY,CAAG,EAIpC,GAAI,KAAK,IAAIM,EAAI,KAAK,IAAIF,EAAIC,CAAC,CAAC,GAAKH,EACjC,OAAAf,EAAK,KAAK,KAAKiB,CAAC,EAChBhB,EAAK,KAAK,KAAKiB,CAAC,EAChBL,EAAK,EACE,CAAE,GAAIb,EAAI,GAAIC,EAAI,GAAIY,CAAG,EAIpC,IAAIQ,EAAIL,EAAG,CAAC,EAAIA,EAAG,CAAC,EAAIA,EAAG,CAAC,EAAIA,EAAG,CAAC,EAGhCM,EAAKF,EAAKD,EAAI,EACdI,EAAKH,EAAKD,EAAI,EAGlB,OAAI,KAAK,IAAIE,CAAC,GAAKN,GAAW,KAAK,IAAIO,EAAKJ,CAAC,GAAKH,GAE9CF,EAAK,EACLb,EAAK,KAAK,KAAKuB,CAAE,EACjBtB,EAAK,KAAK,KAAKqB,CAAE,EACV,CAAE,GAAItB,EAAI,GAAIC,EAAI,GAAIY,CAAG,IAGpCA,EACI,KAAK,KAAK,KAAK,IAAIQ,CAAC,EAAI,KAAK,IAAIC,EAAKJ,CAAC,GAAKI,EAAKL,GAAKI,EAAIA,GAAKC,EAAKJ,EAAE,EACtEJ,EAGAD,GAAM,GAENb,EAAK,KAAK,KAAKsB,CAAE,EACjBrB,EAAK,KAAK,KAAKsB,CAAE,IAGjBV,GAAM,GACNb,EAAK,KAAK,KAAKuB,CAAE,EACjBtB,EAAK,KAAK,KAAKqB,CAAE,GAGd,CAAE,GAAItB,EAAI,GAAIC,EAAI,GAAIY,CAAG,EACpC,CAOA,SAASR,GAAoBmB,EAAaC,EAAazB,EAAYC,EAAYC,EAAeC,EAAkBC,EAAesB,EAAYC,EAAY,CAEnJ,IAAMC,EAAS,CAACC,EAAIC,EAAIC,EAAIC,IAAO,CAC/B,IAAIC,EAAMJ,EAAKE,EAAKD,EAAKE,EACrBE,EAAM,KAAK,MAAML,EAAKA,EAAKC,EAAKA,IAAOC,EAAKA,EAAKC,EAAKA,EAAG,EACzDG,EAAM,KAAK,KAAKF,EAAMC,CAAG,EAC7B,OAAIL,EAAKG,EAAKF,EAAKC,EAAK,IACpBI,EAAM,CAACA,GAEJA,CACX,EAGIC,EAAMpC,IAAOC,EAAK,EAAK,CAACC,EAAQ,KAAK,GAAM,IAE3CmC,EAAIC,EAAIC,EAAYC,EAAYC,EAChCC,EAAK,KAAK,GACVC,EAAOD,EAAK,EAEhB,GAAI1C,GAAM,GAAKC,GAAM,EAEjB,MAAM,MAAM,wBAAwB,GAIpCD,EAAK,GAAKC,EAAK,KACf,CAACD,EAAIC,CAAE,EAAI,CAAC,KAAK,IAAID,CAAE,EAAG,KAAK,IAAIC,CAAE,CAAC,GAG1C,IAAI2C,EAAQR,IAAQ,EAAI,EAAI,KAAK,IAAIA,CAAG,EACpCS,EAAQT,IAAQ,EAAI,EAAI,KAAK,IAAIA,CAAG,EAEpCU,GAAQtB,EAAME,GAAM,EACpBqB,GAAQtB,EAAME,GAAM,EACpBqB,GAAQxB,EAAME,GAAM,EACpBuB,GAAQxB,EAAME,GAAM,EAGpBuB,EAAOL,EAAQC,EAAOF,EAAQG,EAC9BI,EAAON,EAAQE,EAAOH,EAAQE,EAI9BM,EAAUF,EAAOA,GAASlD,EAAKA,GAAOmD,EAAOA,GAASlD,EAAKA,GAE3DmD,EAAS,IACTpD,EAAKA,EAAK,KAAK,KAAKoD,CAAM,EAC1BnD,EAAKA,EAAK,KAAK,KAAKmD,CAAM,GAG9B,IAAIC,EAAOrD,EAAKC,EACZqD,EAAStD,EAAKmD,EACdI,EAAStD,EAAKiD,EACdM,EAAYF,EAASA,EAASC,EAASA,EAC3C,GAAI,CAACC,EACD,MAAM,MAAM,0CAA0C,EAG1D,IAAIC,EAAM,KAAK,KAAK,KAAK,KAAKJ,EAAOA,EAAOG,GAAaA,CAAS,CAAC,EAE/DrD,GAAYC,IACZqD,EAAM,CAACA,GAGX,IAAIC,EAAOD,EAAMH,EAAUrD,EACvB0D,EAAO,CAACF,EAAMF,EAAUvD,EAG5BqC,EAAKQ,EAAQa,EAAMd,EAAQe,EAAMX,EACjCV,EAAKM,EAAQc,EAAMb,EAAQc,EAAMV,EACjC,IAAIW,GAAQV,EAAOQ,GAAO1D,EACtB6D,GAAQX,EAAOQ,GAAO1D,EACtB8D,GAAQX,EAAOQ,GAAO1D,EACtB8D,GAAQZ,EAAOQ,GAAO1D,EAG1BsC,EAAaX,EAAO,EAAG,EAAGgC,EAAME,CAAI,EAGpCtB,EAAaZ,EAAOgC,EAAME,EAAM,CAACD,EAAM,CAACE,CAAI,EAExCvB,EAAaG,EACbH,GAAcG,EACPH,EAAa,IACpBA,GAAcG,GAEdvC,GAAS,IACToC,GAAcG,GAElBF,EAAWF,EAAaC,EACpBC,EAAWE,EACXF,GAAYE,EACLF,EAAW,IAClBA,GAAYE,GAEhB,IAAIqB,EAAc,IAAMtB,EAexB,MAdgB,CACZ,GAAIL,EACJ,GAAIC,EACJ,GAAItC,EACJ,GAAIC,EACJ,eAAgBsC,EAAayB,EAC7B,WAAYzB,EACZ,eAAgBC,EAAawB,EAC7B,WAAYxB,EACZ,aAAcC,EAAWuB,EACzB,SAAUvB,EACV,UAAWrC,GAAS,CACxB,CAGJ,CCnWO,SAAS6D,EAA0BC,EAAoBC,EAAqC,CAE/FA,EAAU,CACN,SAAU,EACV,GAAGA,CACP,EAEUD,EAAI,iBAAqC,4DAA4D,EAC3G,QAAQE,GAAM,CAEVA,aAAc,oBAAsBA,EAAG,WAAa,SACpDA,EAAKC,EAAmBD,CAAE,GAI9BE,GAAwBF,EAAID,CAAO,CACvC,CAAC,EAEYD,EAAI,iBAAiB,GAAG,EAC9B,QAAQK,GAAK,CAChBA,EAAE,gBAAgB,WAAW,EAC7BA,EAAE,gBAAgB,kBAAkB,EACpCA,EAAE,MAAM,eAAe,WAAW,EAClCA,EAAE,MAAM,eAAe,kBAAkB,CAC7C,CAAC,CACL,CAGA,SAASD,GAAwBF,EAAwBD,EAGrD,CAEAA,EAAU,CACN,SAAU,EACV,GAAGA,CACP,EAIA,GAAI,CAAE,SAAAK,CAAS,EAAIL,EAGfM,EAASL,EAAG,gBAChB,GAAaK,IAAT,MAAmB,EAAEA,aAAkB,oBACvC,MAAO,CAAC,EAGZ,IAAIC,EAASD,EAAO,aAAa,EAAG,QAAQ,EAAE,SAASL,EAAG,aAAa,CAAE,EACrE,CAAE,EAAAO,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,CAAE,EAAIL,EAE3B,CAACC,EAAGC,EAAGC,EAAGC,EAAGC,EAAG,CAAC,EAAI,CAACJ,EAAGC,EAAGC,EAAGC,EAAGC,EAAG,CAAC,EAAE,IAAIC,GACjC,CAACA,EAAI,QAAQ,CAAC,CACxB,EAED,IAAIC,EADY,CAACN,EAAGC,EAAGC,EAAGC,EAAGC,EAAG,CAAC,EAAE,KAAK,EAAE,IACR,SAClC,GAAIE,EAAe,CAEf,IAAIC,EAAWC,GAAkBT,CAAM,EAEnCU,GAAS,KAAK,IAAIF,EAAS,MAAM,EAAI,KAAK,IAAIA,EAAS,MAAM,GAAK,EAItE,GAFAG,GAAiBjB,EAAIgB,EAAOZ,CAAQ,EAEhC,EAAAJ,aAAc,oBACd,OAAIa,IACGC,EAAS,cACRd,EAAG,aAAa,YAAac,EAAS,YAAY,EAEtDd,EAAG,gBAAgB,kBAAkB,EACrCA,EAAG,MAAM,eAAe,WAAW,EACnCA,EAAG,MAAM,eAAe,kBAAkB,GAEvC,GAQX,IAAIU,EAAIV,EAAG,aAAa,GAAG,EACvBkB,EAAWC,EAAwBT,CAAC,EAExCQ,EAAWE,EAAkBF,EAAUZ,CAAM,EAG7C,IAAIe,EAAOC,EAAkBJ,EAAUd,CAAQ,EAC/C,OAAAJ,EAAG,aAAa,IAAKqB,CAAI,EACzBrB,EAAG,gBAAgB,WAAW,EAC9BA,EAAG,MAAM,eAAe,WAAW,EAC5BkB,CACX,CACJ,CAGA,SAASD,GAAiBjB,EAAgBgB,EAAeZ,EAAW,EAAG,CACnE,IAAImB,EAAS,OAAO,iBAAiBvB,CAAE,EACnCwB,EAA+BD,EAAO,iBAAiB,cAAc,EAEzEC,EADaD,EAAO,iBAAiB,QAAQ,GACrB,OAAS,KAAK,IAAI,WAAWC,CAAW,EAAIR,CAAK,EAAI,EAGzEQ,GAAexB,EAAG,SAAS,YAAY,IAAM,SAC7CA,EAAG,aAAa,eAAgBwB,EAAY,QAAQpB,EAAW,CAAC,CAAC,EACjEJ,EAAG,MAAM,eAAe,cAAc,EAE9C,CAWA,SAASe,GAAkBT,EAAmBmB,EAAY,EAAG,CACzD,GAAI,CAAE,EAAAlB,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAe,CAAE,EAAIpB,EAEvB,MAAM,QAAQA,CAAM,IACpB,CAACC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGe,CAAC,EAAIpB,GAEzB,IAAIqB,EAAQ,KAAK,MAAMnB,EAAGD,CAAC,EACvBqB,EAAQ,KAAK,IAAIrB,EAAG,CAAC,EAAI,KAAK,IAAIC,EAAG,CAAC,EACtCqB,EAAS,KAAK,KAAKD,CAAK,EACxBE,GAAUvB,EAAIG,EAAID,EAAID,GAAKqB,EAC3BE,EAAQ,KAAK,MAAMxB,EAAIE,EAAID,EAAIE,EAAGkB,CAAK,GAAK,KAAK,GAAK,KACtDI,EAAarB,GAAQ,EACrBsB,EAAaP,GAAQ,EACrBQ,EAASP,EAAQA,GAAS,KAAK,GAAK,KAAO,EAC3Cb,EAUA,CACA,WAAYkB,EACZ,WAAYC,EACZ,OAAQC,EACR,OAAQL,EACR,OAAQC,EACR,MAAOC,EACP,MAAO,CACX,EACII,EAA0B,CAAC,EAC3BC,EAA0B,CAAC,EAC/B,QAASC,KAAQvB,EAAU,CACvBA,EAASuB,CAAI,EAAI,CAAC,WAAWvB,EAASuB,CAAI,CAAC,EAAE,QAAQZ,CAAS,EAC9D,IAAIb,EAAME,EAASuB,CAAI,EACnBC,EAAO,IACPD,GAAQ,UAAYA,GAAQ,WAC5BC,EAAO,OAEPD,EAAK,QAAQ,WAAW,GAAK,KAC7BC,EAAO,MAGX,IAAIC,EAAU,CAAC,SAAU,SAAU,aAAc,YAAY,EACzD3B,IAAQ,GACRuB,EAAc,KAAK,GAAGE,CAAI,IAAIzB,CAAG,GAAG0B,CAAI,GAAG,EAE3CC,EAAQ,QAAQF,CAAI,GAAK,IAAMzB,IAAQ,EACvCwB,EAAc,KAAK,GAAGC,CAAI,IAAIzB,CAAG,GAAG,EAC7ByB,GAAQ,SACfD,EAAc,KACV,SAAS,CAACP,EAAO,QAAQJ,CAAS,CAAC,IAAI,CAACK,EAAO,QAAQL,CAAS,CAAC,GACrE,EACOY,GAAQ,cACfD,EAAc,KACV,aAAatB,EAAS,UAAU,IAAIA,EAAS,UAAU,GAC3D,CAER,CAEA,OAAAA,EAAS,aAAeqB,EAAc,KAAK,GAAG,EAC9CrB,EAAS,aAAesB,EAAc,KAAK,GAAG,EACvCtB,CACX,CC7LO,SAAS0B,EAAUC,EAAoB,CAC1C,IAAMC,EAAOD,EAAI,UAAU,EAAI,EAC/BE,EAA0BD,EAAM,CAAC,CAAC,EAClC,IAAIE,EAAS,SAAS,iBAAiBF,EAAM,WAAW,YAAY,EAEhEG,EAAkC,KAClCC,EAAS,GACb,KAAQD,EAAOD,EAAO,SAAS,GAC3B,GAAKC,GAIDA,aAAgB,mBAAoB,CACpC,IAAIE,EAAIF,EAAK,aAAa,GAAG,EAC7B,GAAGE,EAAG,CACF,IAAIC,EAAOC,EAAwBF,CAAC,EAC9BG,EAAeF,EAAK,UAAUG,GAAKA,EAAE,OAAS,KAAOA,EAAE,OAAS,GAAG,EACnEC,EAASC,GAAUL,EAAK,MAAM,EAAEE,CAAY,CAAC,EACnDF,EAAOA,EAAK,IAAIG,GACTA,EAAE,OAAS,KAAOA,EAAE,OAAS,IACrB,CACH,KAAM,IACN,OAAAC,CACJ,EAEGD,CACV,EACDJ,EAAIO,EAAkBN,CAAI,EAC1BF,GAAUC,CACd,CACJ,CAEJ,OAAOD,CACX,CAEA,SAASO,GAAUE,EAAgBC,EAAO,CAAC,EAAE,CAAC,EAAG,CAE7C,QAAQT,KAAKQ,EAAM,CACf,IAAME,EAAU,CAAC,EAAE,CAAC,EACpB,OAAOV,EAAE,KAAK,YAAY,EAAG,CACzB,IAAK,IACDU,EAAQ,CAAC,EAAIV,EAAE,OAAO,CAAC,EACvB,MACJ,IAAK,IACDU,EAAQ,CAAC,EAAIV,EAAE,OAAO,CAAC,EACvB,MACJ,QACIU,EAAQ,CAAC,EAAIV,EAAE,OAAO,GAAG,EAAE,GAAK,EAChCU,EAAQ,CAAC,EAAIV,EAAE,OAAO,GAAG,EAAE,GAAK,CACxC,CAEGA,EAAE,KAAK,YAAY,IAAMA,EAAE,OAC1BU,EAAQ,CAAC,GAAKD,EAAK,CAAC,EACpBC,EAAQ,CAAC,GAAKD,EAAK,CAAC,GAExBA,EAAK,CAAC,EAAIC,EAAQ,CAAC,EACnBD,EAAK,CAAC,EAAIC,EAAQ,CAAC,CACvB,CACA,OAAOD,CACX,CACA,WAAW,UAAehB,EAC1B,IAAOkB,GAAQlB","names":["parsePathDataNormalized","d","pathData","cmdRegEx","commands","comLengths","offX","offY","lastX","lastY","c","com","type","typeRel","typeAbs","isRel","chunkSize","values","n","arcValues","i","value","largeArc","sweep","finalX","comN","hasMultiple","chunk","comChunks","typeImplicit","typeFirst","valuesL","valuesPrev","valuesPrevL","cp1X","cp1Y","cpN1X","cpN1Y","cp2X","cp2Y","serializePathData","pathData","decimals","d","val","i","com0","com","type","values","svgElUnitsToPixel","el","decimals","svg","translateUnitToPixel","value","dpi","unit","val","rat","widthString","width","heightString","height","vBString","vB","w","h","scaleX","scaleY","scalRoot","attsH","attsV","att","valAbs","scale","convertShapeToPath","el","decimals","pathData","getPathDataFromEl","path","setAttributes","attributes","exclude","key","attArr","attObj","att","d","serializePathData","type","atts","attNames","x","y","width","height","r","rx","ry","cx","cy","x1","x2","y1","y2","svgElUnitsToPixel","getAtts","attr","parsePathDataNormalized","points","transformPathData","pathData","matrix","pathDataTrans","normalizeMatrix","val","com","i","type","values","typeRel","comPrevValues","comPrevValuesL","p0","p","comT","transformArc","ptTrans","transformPoint","pt","a","b","c","d","e","f","x","y","rx","ry","angle","largeArc","sweep","svgArcToCenterParam","ellipsetr","transformEllipse","denom","scaleX","scaleY","flipX","flipY","ax","torad","epsilon","ma","J","K","D","JK","L","l1","l2","p0x","p0y","px","py","radian","ux","uy","vx","vy","dot","mod","rad","phi","cx","cy","startAngle","deltaAngle","endAngle","PI","PIpx","s_phi","c_phi","hd_x","hd_y","hs_x","hs_y","p0x_","p0y_","lambda","rxry","rxp0y_","ryp0x_","sum_of_sq","coe","cx_","cy_","xcr1","xcr2","ycr1","ycr2","toDegFactor","flattenSVGTransformations","svg","options","el","convertShapeToPath","reduceElementTransforms","g","decimals","parent","matrix","a","b","c","d","e","val","isTransformed","transObj","qrDecomposeMatrix","scale","scaleStrokeWidth","pathData","parsePathDataNormalized","transformPathData","dNew","serializePathData","styles","strokeWidth","precision","f","angle","denom","scaleX","scaleY","skewX","translateX","translateY","rotate","cssTransforms","svgTransforms","prop","unit","convert","SvgToPath","svg","copy","flattenSVGTransformations","walker","node","result","d","path","parsePathDataNormalized","nonMoveIndex","e","values","getEndPos","serializePathData","data","pose","current","index_default"]}