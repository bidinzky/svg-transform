{"version":3,"sources":["../src/index.ts","../src/parser.ts","../src/path/arcToCubic.ts","../src/path/toRelative.ts","../src/path/toShorthand.ts","../src/path/index.ts","../src/serialize.ts","../src/helper.ts","../src/shapeToPath.ts","../src/transformPath.ts"],"sourcesContent":["import { parsePathDataNormalized } from \"./parser\";\nimport { convertPathData } from \"./path/index\";\nimport { pathDataArcToCubic } from \"./path/arcToCubic\";\nimport { serializePathData } from \"./serialize\";\nimport { convertShapeToPath } from \"./shapeToPath\";\nimport { transformPathData } from \"./transformPath\";\n\ntype FlattenSvgOptions = {\n    arcsToCubic: boolean;\n    toRelative: boolean;\n    toAbsolute: boolean;\n    toShorthands: boolean;\n    toLonghands: boolean;\n    arcAccuracy: number;\n    minify: boolean;\n    decimals: number\n}\n\nexport function flattenSVGTransformations(svg: SVGSVGElement, options: Partial<FlattenSvgOptions>) {\n\n    options = {\n        arcsToCubic: false,\n        toRelative: true,\n        toAbsolute: false,\n        toLonghands: true,\n        toShorthands: true,\n        arcAccuracy: 1,\n        minify: true,\n        decimals: 3,\n        ...options\n    };\n\n    let els = svg.querySelectorAll<SVGGraphicsElement>('text, path, polyline, polygon, line, rect, circle, ellipse');\n    els.forEach(el => {\n        // convert shapes to paths\n        if (el instanceof SVGGeometryElement && el.nodeName !== 'path') {\n            el = convertShapeToPath(el)\n        }\n\n        //flatten element transformations\n        reduceElementTransforms(el, options);\n    });\n    // remove group transforms\n    let groups = svg.querySelectorAll('g');\n    groups.forEach(g => {\n        g.removeAttribute('transform');\n        g.removeAttribute('transform-origin');\n        g.style.removeProperty('transform');\n        g.style.removeProperty('transform-origin');\n    });\n}\n\n\nfunction reduceElementTransforms(el: SVGGraphicsElement, options: Partial<{\n    arcsToCubic: boolean;\n    arcAccuracy: number;\n    minify: boolean;\n    decimals: number;\n}>) {\n\n    options = {\n        arcsToCubic: false,\n        arcAccuracy: 1,\n        minify: true,\n        decimals: 3,\n        ...options\n    };\n\n\n    //decimals = 3, arcsToCubic = false, arcAccuracy = 1\n    let { arcsToCubic, arcAccuracy, minify, decimals } = options;\n\n\n    let parent = el.viewportElement;\n    if (null === parent || !(parent instanceof SVGGraphicsElement)) {\n        return [];\n    }\n    // check elements transformations\n    let matrix = parent.getScreenCTM()!.inverse().multiply(el.getScreenCTM()!);\n    let { a, b, c, d, e, f } = matrix;\n    // round matrix\n    [a, b, c, d, e, f] = [a, b, c, d, e, f].map(val => {\n        return +val.toFixed(3)\n    });\n    let matrixStr = [a, b, c, d, e, f].join('');\n    let isTransformed = matrixStr !== \"100100\" ? true : false;\n    if (isTransformed) {\n        // matrix to readable transfomr functions\n        let transObj = qrDecomposeMatrix(matrix);\n        // scale stroke-width\n        let scale = (Math.abs(transObj.scaleX) + Math.abs(transObj.scaleY)) / 2;\n\n        scaleStrokeWidth(el, scale, decimals)\n        // if text element: consolidate all applied transforms \n        if (el instanceof SVGGeometryElement === false) {\n            if (isTransformed) {\n                if(transObj.svgTransform) {\n                    el.setAttribute('transform', transObj.svgTransform);\n                }\n                el.removeAttribute('transform-origin');\n                el.style.removeProperty('transform');\n                el.style.removeProperty('transform-origin');\n            }\n            return false\n        }\n        /**\n         * is geometry elements: \n         * recalculate pathdata\n         * according to transforms\n         * by matrix transform\n         */\n        let d = el.getAttribute(\"d\")!;\n        let pathData = parsePathDataNormalized(d);\n\n        if (arcsToCubic) {\n            pathData = pathDataArcToCubic(pathData, arcAccuracy)\n        }\n\n        pathData = transformPathData(pathData, matrix)\n\n\n        //optimize output\n        pathData = convertPathData(pathData, options)\n\n\n        // apply pathdata - remove transform\n        let dNew = serializePathData(pathData, decimals, minify)\n        el.setAttribute('d', dNew);\n        el.removeAttribute('transform');\n        el.style.removeProperty('transform');\n        return pathData;\n    }\n}\n\n\nfunction scaleStrokeWidth(el, scale, decimals = 3) {\n    let styles = window.getComputedStyle(el);\n    let strokeWidth: string | number = styles.getPropertyValue('stroke-width');\n    let stroke = styles.getPropertyValue('stroke');\n    strokeWidth = stroke != 'none' ? Math.abs(parseFloat(strokeWidth) * scale) : 0;\n\n    // exclude text elements, since they remain transformed\n    if (strokeWidth && el.nodeName.toLowerCase() !== 'text') {\n        el.setAttribute('stroke-width', +strokeWidth.toFixed(decimals + 2));\n        el.style.removeProperty('stroke-width');\n    }\n}\n\n\n/**\n *  Decompose matrix to readable transform properties \n *  translate() rotate() scale() etc.\n *  based on @AndreaBogazzi's answer\n *  https://stackoverflow.com/questions/5107134/find-the-rotation-and-skew-of-a-matrix-transformation#32125700\n *  return object with seperate transform properties \n *  and ready to use css or svg attribute strings\n */\nfunction qrDecomposeMatrix(matrix: SVGMatrix, precision = 3) {\n    let { a, b, c, d, e, f } = matrix;\n    // matrix is array\n    if (Array.isArray(matrix)) {\n        [a, b, c, d, e, f] = matrix;\n    }\n    let angle = Math.atan2(b, a),\n        denom = Math.pow(a, 2) + Math.pow(b, 2),\n        scaleX = Math.sqrt(denom),\n        scaleY = (a * d - c * b) / scaleX,\n        skewX = Math.atan2(a * c + b * d, denom) / (Math.PI / 180),\n        translateX = e ? e : 0,\n        translateY = f ? f : 0,\n        rotate = angle ? angle / (Math.PI / 180) : 0;\n    let transObj: {\n        translateX: number;\n        translateY: number;\n        rotate: number;\n        scaleX: number;\n        scaleY: number;\n        skewX: number;\n        skewY: number;\n        cssTransform?: string;\n        svgTransform?: string;\n    } = {\n        translateX: translateX,\n        translateY: translateY,\n        rotate: rotate,\n        scaleX: scaleX,\n        scaleY: scaleY,\n        skewX: skewX,\n        skewY: 0,\n    };\n    let cssTransforms: string[] = [];\n    let svgTransforms: string[] = [];\n    for (let prop in transObj) {\n        transObj[prop] = +parseFloat(transObj[prop]).toFixed(precision);\n        let val = transObj[prop];\n        let unit = \"\";\n        if (prop == \"rotate\" || prop == \"skewX\") {\n            unit = \"deg\";\n        }\n        if (prop.indexOf(\"translate\") != -1) {\n            unit = \"px\";\n        }\n        // combine these properties\n        let convert = [\"scaleX\", \"scaleY\", \"translateX\", \"translateY\"];\n        if (val !== 0) {\n            cssTransforms.push(`${prop}(${val}${unit})`);\n        }\n        if (convert.indexOf(prop) == -1 && val !== 0) {\n            svgTransforms.push(`${prop}(${val})`);\n        } else if (prop == \"scaleX\") {\n            svgTransforms.push(\n                `scale(${+scaleX.toFixed(precision)} ${+scaleY.toFixed(precision)})`\n            );\n        } else if (prop == \"translateX\") {\n            svgTransforms.push(\n                `translate(${transObj.translateX} ${transObj.translateY})`\n            );\n        }\n    }\n    // append css style string to object\n    transObj.cssTransform = cssTransforms.join(\" \");\n    transObj.svgTransform = svgTransforms.join(\" \");\n    return transObj;\n}\n\n\n","/**\n * Standalone pathData parser\n * returns a pathData array compliant\n * with the w3C SVGPathData interface draft\n * https://svgwg.org/specs/paths/#InterfaceSVGPathData\n * Usage example:\n */\n\nimport { PathData } from \"./type\";\n\nexport function parsePathDataNormalized(d: string) {\n    d = d\n        // remove new lines, tabs an comma with whitespace\n        .replace(/[\\n\\r\\t|,]/g, \" \")\n        // pre trim left and right whitespace\n        .trim()\n        // add space before minus sign\n        .replace(/(\\d)-/g, \"$1 -\")\n        // decompose multiple adjacent decimal delimiters like 0.5.5.5 => 0.5 0.5 0.5\n        .replace(/(\\.)(?=(\\d+\\.\\d+)+)(\\d+)/g, \"$1$3 \");\n\n    let pathData: PathData = [];\n    let cmdRegEx = /([mlcqazvhst])([^mlcqazvhst]*)/gi;\n    let commands = d.match(cmdRegEx);\n\n    if (null === commands) {\n        return pathData;\n    }\n\n    // valid command value lengths\n    let comLengths = { m: 2, a: 7, c: 6, h: 1, l: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };\n\n    // offsets for absolute conversion\n    let offX, offY, lastX, lastY;\n\n    for (let c = 0; c < commands.length; c++) {\n        let com = commands[c];\n        let type = com.substring(0, 1);\n        let typeRel = type.toLowerCase();\n        let typeAbs = type.toUpperCase();\n        let isRel = type === typeRel;\n        let chunkSize = comLengths[typeRel];\n\n        // split values to array\n        let values: string[] | number[] = com.substring(1, com.length).trim().split(\" \").filter(Boolean);\n\n        /**\n         * A - Arc commands\n         * large arc and sweep flags\n         * are boolean and can be concatenated like\n         * 11 or 01\n         * or be concatenated with the final on path points like\n         * 1110 10 => 1 1 10 10\n         */\n        if (typeRel === \"a\" && values.length != comLengths.a) {\n            let n = 0,\n                arcValues: string[] = [];\n            for (let i = 0; i < values.length; i++) {\n                let value = values[i];\n\n                // reset counter\n                if (n >= chunkSize) {\n                    n = 0;\n                }\n                // if 3. or 4. parameter longer than 1\n                if ((n === 3 || n === 4) && value.length > 1) {\n                    let largeArc = n === 3 ? value.substring(0, 1) : \"\";\n                    let sweep = n === 3 ? value.substring(1, 2) : value.substring(0, 1);\n                    let finalX = n === 3 ? value.substring(2) : value.substring(1);\n                    let comN = [largeArc, sweep, finalX].filter(Boolean);\n                    arcValues.push(...comN);\n                    n += comN.length;\n                } else {\n                    // regular\n                    arcValues.push(value);\n                    n++;\n                }\n            }\n            values = arcValues.flat().filter(Boolean);\n        }\n\n        // string  to number\n        values = values.map(Number);\n\n        // if string contains repeated shorthand commands - split them\n        let hasMultiple = values.length > chunkSize;\n        let chunk = hasMultiple ? values.slice(0, chunkSize) : values;\n        let comChunks = [{ type: type, values: chunk }];\n\n        // has implicit or repeated commands â€“ split into chunks\n        if (hasMultiple) {\n            let typeImplicit = typeRel === \"m\" ? (isRel ? \"l\" : \"L\") : type;\n            for (let i = chunkSize; i < values.length; i += chunkSize) {\n                let chunk = values.slice(i, i + chunkSize);\n                comChunks.push({ type: typeImplicit, values: chunk });\n            }\n        }\n\n        /**\n         * convert to absolute\n         * init offset from 1st M\n         */\n        if (c === 0) {\n            offX = values[0];\n            offY = values[1];\n            lastX = offX;\n            lastY = offY;\n        }\n\n        let typeFirst = comChunks[0].type;\n        typeAbs = typeFirst.toUpperCase();\n\n        // first M is always absolute\n        isRel =\n            typeFirst.toLowerCase() === typeFirst && pathData.length ? true : false;\n\n        for (let i = 0; i < comChunks.length; i++) {\n            let com = comChunks[i];\n            let type = com.type;\n            let values = com.values;\n            let valuesL = values.length;\n            let comPrev = comChunks[i - 1]\n                ? comChunks[i - 1]\n                : c > 0 && pathData[pathData.length - 1]\n                    ? pathData[pathData.length - 1]\n                    : comChunks[i];\n\n            let valuesPrev = comPrev.values;\n            let valuesPrevL = valuesPrev.length;\n            isRel =\n                comChunks.length > 1\n                    ? type.toLowerCase() === type && pathData.length > 0\n                    : isRel;\n\n            if (isRel) {\n                com.type = comChunks.length > 1 ? type.toUpperCase() : typeAbs;\n\n                switch (typeRel) {\n                    case \"a\":\n                        com.values = [\n                            values[0],\n                            values[1],\n                            values[2],\n                            values[3],\n                            values[4],\n                            values[5] + offX,\n                            values[6] + offY\n                        ];\n                        break;\n\n                    case \"h\":\n                    case \"v\":\n                        com.values = type === \"h\" ? [values[0] + offX] : [values[0] + offY];\n                        break;\n\n                    case \"m\":\n                    case \"l\":\n                    case \"t\":\n                        com.values = [values[0] + offX, values[1] + offY];\n                        break;\n\n                    case \"c\":\n                        com.values = [\n                            values[0] + offX,\n                            values[1] + offY,\n                            values[2] + offX,\n                            values[3] + offY,\n                            values[4] + offX,\n                            values[5] + offY\n                        ];\n                        break;\n\n                    case \"q\":\n                    case \"s\":\n                        com.values = [\n                            values[0] + offX,\n                            values[1] + offY,\n                            values[2] + offX,\n                            values[3] + offY\n                        ];\n                        break;\n                }\n            }\n            // is absolute\n            else {\n                offX = 0;\n                offY = 0;\n            }\n\n            /**\n             * convert shorthands\n             */\n            let shorthandTypes = [\"H\", \"V\", \"S\", \"T\"];\n\n            if (shorthandTypes.includes(typeAbs)) {\n                let cp1X, cp1Y, cpN1X, cpN1Y, cp2X, cp2Y;\n                if (com.type === \"H\" || com.type === \"V\") {\n                    com.values =\n                        com.type === \"H\" ? [com.values[0], lastY] : [lastX, com.values[0]];\n                    com.type = \"L\";\n                } else if (com.type === \"T\" || com.type === \"S\") {\n                    [cp1X, cp1Y] = [valuesPrev[0], valuesPrev[1]];\n                    [cp2X, cp2Y] =\n                        valuesPrevL > 2\n                            ? [valuesPrev[2], valuesPrev[3]]\n                            : [valuesPrev[0], valuesPrev[1]];\n\n                    // new control point\n                    cpN1X = com.type === \"T\" ? lastX * 2 - cp1X : lastX * 2 - cp2X;\n                    cpN1Y = com.type === \"T\" ? lastY * 2 - cp1Y : lastY * 2 - cp2Y;\n\n                    com.values = [cpN1X, cpN1Y, com.values].flat();\n                    com.type = com.type === \"T\" ? \"Q\" : \"C\";\n                }\n            }\n\n            // add to pathData array\n            pathData.push(com);\n\n            // update offsets\n            lastX =\n                valuesL > 1\n                    ? values[valuesL - 2] + offX\n                    : typeRel === \"h\"\n                        ? values[0] + offX\n                        : lastX;\n            lastY =\n                valuesL > 1\n                    ? values[valuesL - 1] + offY\n                    : typeRel === \"v\"\n                        ? values[0] + offY\n                        : lastY;\n            offX = lastX;\n            offY = lastY;\n        }\n    }\n\n    /**\n     * first M is always absolute/uppercase -\n     * unless it adds relative linetos\n     * (facilitates d concatenating)\n     */\n    pathData[0].type = \"M\";\n\n    return pathData;\n}","import type { Point, PathData, PathElement } from \"../type\";\n\n/** \n * convert arctocommands to cubic bezier\n * based on puzrin's a2c.js\n * https://github.com/fontello/svgpath/blob/master/lib/a2c.js\n * returns pathData array\n*/\nexport function pathDataArcToCubic(pathData: PathData, arcAccuracy = 1) {\n    let pathDataAbs: PathData = []\n    pathData.forEach((com, i) => {\n        let { type, values } = com;\n        let comPrev = i > 0 ? pathData[i - 1] : com;\n        let valuesPrev = comPrev.values;\n        let valuesPrevL = valuesPrev.length;\n        let p0 = { x: valuesPrev[valuesPrevL - 2], y: valuesPrev[valuesPrevL - 1] };\n\n        if (type.toLowerCase() === 'a') {\n            let cubicArcs = arcToBezier(p0, values, arcAccuracy);\n            for (let i = 0; i < cubicArcs.length; i++) {\n                let cubicArc = cubicArcs[i]\n                pathDataAbs.push(cubicArc);\n            }\n        } else {\n            pathDataAbs.push(com);\n        }\n\n    })\n    return pathDataAbs\n}\n\n\nfunction arcToBezier(p0: Point, values: number[], splitSegments = 1) {\n    const TAU = Math.PI * 2;\n    let [rx, ry, rotation, largeArcFlag, sweepFlag, x, y] = values;\n\n    if (rx === 0 || ry === 0) {\n        return []\n    }\n\n    let phi = rotation ? rotation * TAU / 360 : 0;\n    let sinphi = phi ? Math.sin(phi) : 0\n    let cosphi = phi ? Math.cos(phi) : 1\n    let pxp = cosphi * (p0.x - x) / 2 + sinphi * (p0.y - y) / 2\n    let pyp = -sinphi * (p0.x - x) / 2 + cosphi * (p0.y - y) / 2\n\n    if (pxp === 0 && pyp === 0) {\n        return []\n    }\n    rx = Math.abs(rx)\n    ry = Math.abs(ry)\n    let lambda =\n        pxp * pxp / (rx * rx) +\n        pyp * pyp / (ry * ry)\n    if (lambda > 1) {\n        let lambdaRt = Math.sqrt(lambda);\n        rx *= lambdaRt\n        ry *= lambdaRt\n    }\n\n    /** \n     * parametrize arc to \n     * get center point start and end angles\n     */\n    let rxsq = rx * rx,\n        rysq = rx === ry ? rxsq : ry * ry\n\n    let pxpsq = pxp * pxp,\n        pypsq = pyp * pyp\n    let radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq)\n\n    if (radicant <= 0) {\n        radicant = 0\n    } else {\n        radicant /= (rxsq * pypsq) + (rysq * pxpsq)\n        radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1)\n    }\n\n    let centerxp = radicant ? radicant * rx / ry * pyp : 0\n    let centeryp = radicant ? radicant * -ry / rx * pxp : 0\n    let centerx = cosphi * centerxp - sinphi * centeryp + (p0.x + x) / 2\n    let centery = sinphi * centerxp + cosphi * centeryp + (p0.y + y) / 2\n\n    let vx1 = (pxp - centerxp) / rx\n    let vy1 = (pyp - centeryp) / ry\n    let vx2 = (-pxp - centerxp) / rx\n    let vy2 = (-pyp - centeryp) / ry\n\n    // get start and end angle\n    const vectorAngle = (ux, uy, vx, vy) => {\n        let dot = +(ux * vx + uy * vy).toFixed(9)\n        if (dot === 1 || dot === -1) {\n            return dot === 1 ? 0 : Math.PI\n        }\n        dot = dot > 1 ? 1 : (dot < -1 ? -1 : dot)\n        let sign = (ux * vy - uy * vx < 0) ? -1 : 1\n        return sign * Math.acos(dot);\n    }\n\n    let ang1 = vectorAngle(1, 0, vx1, vy1),\n        ang2 = vectorAngle(vx1, vy1, vx2, vy2)\n\n    if (sweepFlag === 0 && ang2 > 0) {\n        ang2 -= Math.PI * 2\n    }\n    else if (sweepFlag === 1 && ang2 < 0) {\n        ang2 += Math.PI * 2\n    }\n\n    let ratio = +(Math.abs(ang2) / (TAU / 4)).toFixed(0)\n\n    // increase segments for more accureate length calculations\n    let segments = ratio * splitSegments;\n    ang2 /= segments\n    let pathDataArc: PathData = [];\n\n\n    // If 90 degree circular arc, use a constant\n    // https://pomax.github.io/bezierinfo/#circles_cubic\n    // k=0.551784777779014\n    const angle90 = 1.5707963267948966;\n    const k = 0.551785\n    let a = ang2 === angle90 ? k :\n        (\n            ang2 === -angle90 ? -k : 4 / 3 * Math.tan(ang2 / 4)\n        );\n\n    let cos2 = ang2 ? Math.cos(ang2) : 1;\n    let sin2 = ang2 ? Math.sin(ang2) : 0;\n    let type = 'C'\n\n    const approxUnitArc = (ang1, ang2, a, cos2, sin2) => {\n        let x1 = ang1 != ang2 ? Math.cos(ang1) : cos2;\n        let y1 = ang1 != ang2 ? Math.sin(ang1) : sin2;\n        let x2 = Math.cos(ang1 + ang2);\n        let y2 = Math.sin(ang1 + ang2);\n\n        return [\n            { x: x1 - y1 * a, y: y1 + x1 * a },\n            { x: x2 + y2 * a, y: y2 - x2 * a },\n            { x: x2, y: y2 }\n        ];\n    }\n\n    for (let i = 0; i < segments; i++) {\n        let com: PathElement = { type: type, values: [] };\n        let curve = approxUnitArc(ang1, ang2, a, cos2, sin2);\n\n        curve.forEach((pt) => {\n            let x = pt.x * rx\n            let y = pt.y * ry\n            com.values.push(cosphi * x - sinphi * y + centerx, sinphi * x + cosphi * y + centery)\n        })\n        pathDataArc.push(com);\n        ang1 += ang2\n    }\n\n    return pathDataArc;\n}\n\n","import { PathData } from \"../type\";\n\n/**\n * This is just a port of Dmitry Baranovskiy's\n * pathToRelative/Absolute methods used in snap.svg\n * https://github.com/adobe-webplatform/Snap.svg/\n *\n * Demo: https://codepen.io/herrstrietzel/pen/poVKbgL\n */\n// convert to relative commands\nexport function pathDataToRelative(pathData: PathData, decimals = -1) {\n\n    // pre-round coordinates to prevent distortions for lower floating point accuracy\n    if (decimals > -1) {\n        pathData.forEach(com => {\n            com.values = com.type.toLowerCase() !== 'a' ? com.values.map(val => { return +val.toFixed(decimals) }) : com.values\n        })\n    }\n\n    let M = pathData[0].values;\n    let x = M[0],\n        y = M[1],\n        mx = x,\n        my = y;\n\n    // loop through commands\n    for (let i = 1; i < pathData.length; i++) {\n        let com = pathData[i];\n        let { type, values } = com;\n        let typeRel = type.toLowerCase();\n\n        // is absolute\n        if (type != typeRel) {\n            type = typeRel;\n            com.type = type;\n            // check current command types\n            switch (typeRel) {\n                case \"a\":\n                    values[5] = +(values[5] - x);\n                    values[6] = +(values[6] - y);\n                    break;\n                case \"v\":\n                    values[0] = +(values[0] - y);\n                    break;\n                case \"m\":\n                    mx = values[0];\n                    my = values[1];\n                default:\n                    // other commands\n                    if (values.length) {\n                        for (let v = 0; v < values.length; v++) {\n                            // even value indices are y coordinates\n                            values[v] = values[v] - (v % 2 ? y : x);\n                        }\n                    }\n            }\n        }\n        // is already relative\n        else if (type == \"m\") {\n            mx = values[0] + x;\n            my = values[1] + y;\n        }\n        let vLen = values.length;\n        switch (type) {\n            case \"z\":\n                x = mx;\n                y = my;\n                break;\n            case \"h\":\n                x += values[vLen - 1];\n                break;\n            case \"v\":\n                y += values[vLen - 1];\n                break;\n            default:\n                x += values[vLen - 2];\n                y += values[vLen - 1];\n        }\n        // round final relative values\n        if (decimals > -1) {\n            if (typeRel === 'a') {\n                com.values = [\n                    +com.values[0].toFixed(decimals + 2),\n                    +com.values[1].toFixed(decimals + 2),\n                    +com.values[2].toFixed(decimals + 2),\n                    +com.values[3],\n                    +com.values[4],\n                    +com.values[5].toFixed(decimals + 1),\n                    +com.values[6].toFixed(decimals + 1)\n                ]\n\n            } else {\n                com.values = com.values.map((val) => {\n                    return +val.toFixed(decimals);\n                });\n            }\n        }\n    }\n\n    return pathData;\n}\n","import { PathData } from \"../type\";\n\n/**\n * apply shorthand commands if possible\n * L, L, C, Q => H, V, S, T\n * reversed method: pathDataToLonghands()\n */\nexport function pathDataToShorthands(pathData: PathData, decimals = -1) {\n\n    let comShort = {\n        type: \"M\",\n        values: pathData[0].values\n    };\n    let pathDataShorts = [comShort];\n    for (let i = 1; i < pathData.length; i++) {\n        let com = pathData[i];\n        let { type, values } = com;\n        let valuesL = values.length;\n        let comPrev = pathData[i - 1];\n        let valuesPrev = comPrev.values;\n        let valuesPrevL = valuesPrev.length;\n        let [x, y] = [values[valuesL - 2], values[valuesL - 1]];\n        let cp1X, cp1Y, cp2X, cp2Y;\n        let [prevX, prevY] = [\n            valuesPrev[valuesPrevL - 2],\n            valuesPrev[valuesPrevL - 1]\n        ];\n        let val0R,\n            cpN1XR,\n            val1R,\n            cpN1YR,\n            cpN1X,\n            cpN1Y,\n            cpN2X,\n            cpN2Y,\n            prevXR,\n            prevYR;\n\n        switch (type) {\n            case \"L\":\n                // round coordinates for some tolerance\n                [val0R, prevXR, val1R, prevYR] = [values[0], prevX, values[1], prevY];\n\n                if (comPrev.type !== \"H\" && comPrev.type !== \"V\") {\n                    [val0R, prevXR, val1R, prevYR] = [val0R, prevXR, val1R, prevYR].map(\n                        (val) => {\n                            return +val.toFixed(2);\n                        }\n                    );\n                }\n\n                if (prevYR == val1R && prevXR !== val0R) {\n                    comShort = {\n                        type: \"H\",\n                        values: [values[0]]\n                    };\n                } else if (prevXR == val0R && prevYR !== val1R) {\n                    comShort = {\n                        type: \"V\",\n                        values: [values[1]]\n                    };\n                } else {\n                    comShort = com;\n                }\n                break;\n            case \"Q\":\n                [cp1X, cp1Y] = [valuesPrev[0], valuesPrev[1]];\n                [prevX, prevY] = [\n                    valuesPrev[valuesPrevL - 2],\n                    valuesPrev[valuesPrevL - 1]\n                ];\n                // Q control point\n                cpN1X = prevX + (prevX - cp1X);\n                cpN1Y = prevY + (prevY - cp1Y);\n\n                /**\n                 * control points can be reflected\n                 * use rounded values for better tolerance\n                 */\n                [val0R, cpN1XR, val1R, cpN1YR] = [\n                    values[0],\n                    cpN1X,\n                    values[1],\n                    cpN1Y\n                ].map((val) => {\n                    return +val.toFixed(1);\n                });\n\n                if (val0R == cpN1XR && val1R == cpN1YR) {\n                    comShort = {\n                        type: \"T\",\n                        values: [x, y]\n                    };\n                } else {\n                    comShort = com;\n                }\n                break;\n            case \"C\":\n                [cp1X, cp1Y] = [valuesPrev[0], valuesPrev[1]];\n                [cp2X, cp2Y] =\n                    valuesPrevL > 2\n                        ? [valuesPrev[2], valuesPrev[3]]\n                        : [valuesPrev[0], valuesPrev[1]];\n                [prevX, prevY] = [\n                    valuesPrev[valuesPrevL - 2],\n                    valuesPrev[valuesPrevL - 1]\n                ];\n                // C control points\n                cpN1X = 2 * prevX - cp2X;\n                cpN1Y = 2 * prevY - cp2Y;\n                cpN2X = values[2];\n                cpN2Y = values[3];\n\n                /**\n                 * control points can be reflected\n                 * use rounded values for better tolerance\n                 */\n                [val0R, cpN1XR, val1R, cpN1YR] = [\n                    values[0],\n                    cpN1X,\n                    values[1],\n                    cpN1Y\n                ].map((val) => {\n                    return +val.toFixed(1);\n                });\n\n                if (val0R == cpN1XR && val1R == cpN1YR) {\n                    comShort = {\n                        type: \"S\",\n                        values: [cpN2X, cpN2Y, x, y]\n                    };\n                } else {\n                    comShort = com;\n                }\n                break;\n            default:\n                comShort = {\n                    type: type,\n                    values: values\n                };\n        }\n\n        // round final values\n        if (decimals > -1) {\n            comShort.values = comShort.values.map((val) => {\n                return +val.toFixed(decimals);\n            });\n        }\n\n        pathDataShorts.push(comShort);\n    }\n    return pathDataShorts;\n}","import { PathData } from \"../type\";\nimport { pathDataArcToCubic } from \"./arcToCubic\";\nimport { pathDataToRelative } from \"./toRelative\";\nimport { pathDataToShorthands } from \"./toShorthand\";\n\n\nexport function convertPathData(pathData: PathData, options: Partial<{\n    arcsToCubic: boolean,\n    toRelative: boolean,\n    toShorthands: boolean,\n    decimals: number,\n    arcAccuracy: number,\n}>) {\n    options = {\n        ...{\n            arcsToCubic: false,\n            toRelative: true,\n            toShorthands: true,\n            decimals: 3,\n            arcAccuracy: 1,\n        },\n        ...options,\n    };\n\n    //decimals = 3, arcsToCubic = false, arcAccuracy = 1\n    let { arcsToCubic, toRelative, toShorthands, arcAccuracy, decimals } = options;\n\n    /**\n    * optimise pathData:\n    * apply shorthands if possible\n    * use relative commands, round pathdata\n    */\n    if (arcsToCubic) {\n        pathData = pathDataArcToCubic(pathData, arcAccuracy)\n    }\n\n    if (toShorthands) {\n        pathData = pathDataToShorthands(pathData)\n    }\n    if (toRelative) {\n        pathData = pathDataToRelative(pathData, decimals)\n    }\n\n    return pathData\n\n}\n","import type { PathData } from \"./type\";\n\n/**\n * serialize pathData array to\n * d attribute string\n */\nexport function serializePathData(pathData: PathData, decimals = -1, minify = false) {\n    // implicit l command\n    if (pathData[1].type === \"l\" && minify) {\n        pathData[0].type = \"m\";\n    }\n\n    let d = `${pathData[0].type}${pathData[0].values.map(val => { return +val.toFixed(decimals) }).join(\" \")}`;\n\n    for (let i = 1; i < pathData.length; i++) {\n        let com0 = pathData[i - 1];\n        let com = pathData[i];\n        let { type, values } = com;\n\n        // minify arctos\n        // yet another arc exception ... since they need more accuracy for rx, ry, x-rotation\n        if (type === \"a\" || type === \"A\" && decimals > -1) {\n            values = [\n                +values[0].toFixed(decimals + 1),\n                +values[1].toFixed(decimals + 1),\n                +values[2].toFixed(decimals + 1),\n                values[3],\n                values[4],\n                +values[5].toFixed(decimals),\n                +values[6].toFixed(decimals)\n            ];\n        }\n\n        // round\n        else if (values.length && decimals > -1) {\n            values = values.map((val) => {\n                return typeof val === \"number\" ? +val.toFixed(decimals) : val;\n            });\n        }\n\n        // omit type for repeated commands\n        type = com0.type === com.type && com.type.toLowerCase() != \"m\" && minify\n            ? \" \"\n            : ((com0.type === \"m\" && com.type === \"l\") ||\n                (com0.type === \"M\" && com.type === \"l\") ||\n                (com0.type === \"M\" && com.type === \"L\")) &&\n                minify\n                ? \" \"\n                : com.type;\n\n        d += `${type}${values.join(\" \")}`;\n    }\n\n    if (minify) {\n        d = d\n            .replaceAll(\" 0.\", \" .\")\n            .replaceAll(\" -\", \"-\")\n            .replaceAll(\"-0.\", \"-.\")\n            .replaceAll(\" .\", \".\")\n            .replaceAll(\"Z\", \"z\");\n    }\n    return d;\n}\n\n","\nexport function svgElUnitsToPixel(el: SVGElement, decimals = 5) {\n    const svg = (el.nodeName !== \"svg\" ? el.closest(\"svg\") : el) as SVGSVGElement;\n\n    // convert real life units to pixels\n    const translateUnitToPixel = (value) => {\n\n        if (value === null) {\n            return 0\n        }\n        //default dpi = 96\n        let dpi = 96;\n        let unit = value.match(/([a-z]+)/gi);\n        unit = unit ? unit[0] : \"\";\n        let val = parseFloat(value);\n        let rat;\n\n        // no unit - already pixes/user unit\n        if (!unit) {\n            return val;\n        }\n\n        switch (unit) {\n            case \"in\":\n                rat = dpi;\n                break;\n            case \"pt\":\n                rat = (1 / 72) * 96;\n                break;\n            case \"cm\":\n                rat = (1 / 2.54) * 96;\n                break;\n            case \"mm\":\n                rat = ((1 / 2.54) * 96) / 10;\n                break;\n            // just a default approximation\n            case \"em\":\n                rat = 16;\n                break;\n            default:\n                rat = 1;\n        }\n        let valuePx = val * rat;\n        return +valuePx.toFixed(decimals);\n    };\n\n    // svg width and height attributes\n    const widthString = svg.getAttribute(\"width\");\n    const width = widthString ? translateUnitToPixel(widthString) : 300;\n    const heightString = svg.getAttribute(\"height\");\n    const height = widthString ? translateUnitToPixel(heightString) : 150;\n\n    //prefer viewBox values\n    const vBString = svg.getAttribute(\"viewBox\");\n    const vB = vBString\n        ? vBString\n            .replace(/,/g, \" \")\n            .split(\" \")\n            .filter(Boolean)\n            .map((val) => {\n                return +val;\n            })\n        : [];\n\n    let w = vB.length ? vB[2] : width;\n    let h = vB.length ? vB[3] : height;\n    let scaleX = 0.01 * w;\n    let scaleY = 0.01 * h;\n    let scalRoot = Math.sqrt((Math.pow(scaleX, 2) + Math.pow(scaleY, 2)) / 2);\n    let attsH = [\"x\", \"width\", \"x1\", \"x2\", \"rx\", \"cx\", \"r\"];\n    let attsV = [\"y\", \"height\", \"y1\", \"y2\", \"ry\", \"cy\"];\n\n\n    let atts = el.getAttributeNames();\n    atts.forEach((att) => {\n        let val = el.getAttribute(att);\n        let valAbs: string | number | null = val;\n        if ((attsH.includes(att) || attsV.includes(att)) && val && valAbs) {\n            let scale = attsH.includes(att) ? scaleX : scaleY;\n            scale = att === \"r\" && w != h ? scalRoot : scale;\n            if (val.includes(\"%\")) {\n                valAbs = parseFloat(val) * scale;\n            }\n            //absolute units\n            else {\n                valAbs = translateUnitToPixel(val);\n            }\n            el.setAttribute(att, valAbs.toString());\n        }\n    });\n}\n","/**\n * retrieve patData from primitives:\n * <circle>, <ellipse>, <rect>, <polygon>, <polyline>, <line>, \n */\n\nimport { svgElUnitsToPixel } from \"./helper\";\nimport { parsePathDataNormalized } from \"./parser\";\nimport { serializePathData } from \"./serialize\";\nimport { PathData } from \"./type\";\n\nexport function convertShapeToPath(el: SVGGeometryElement, decimals = 3) {\n    let pathData = getPathDataFromEl(el);\n\n    // create path element\n    let path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n\n    // get all attributes as object\n    const setAttributes = (el: SVGGeometryElement, attributes: Record<string, string>, exclude: string[] = []) => {\n        for (let key in attributes) {\n            if (exclude.indexOf(key) === -1) {\n                el.setAttribute(key, attributes[key]);\n            }\n        }\n    }\n    const getAttributes = (el: SVGGeometryElement) => {\n        let attArr = [...el.attributes];\n        let attObj: Record<string, string> = {};\n        attArr.forEach((att) => {\n            if (att.nodeValue) {\n                attObj[att.nodeName] = att.nodeValue;\n            }\n        });\n        return attObj;\n    }\n\n    let attributes = getAttributes(el);\n\n    //exclude attributes not needed for paths\n    let exclude = [\"x\", \"y\", \"x1\", \"y1\", \"x2\", \"y2\", \"cx\", \"cy\", \"r\", \"rx\", \"ry\", \"points\", \"width\", \"height\"];\n\n    // copy attributes to path and set pathData\n    setAttributes(path, attributes, exclude);\n    let d = serializePathData(pathData, decimals)\n    path.setAttribute('d', d);\n    el.replaceWith(path);\n    return path;\n}\n\n// retrieve pathdata from svg geometry elements\nexport function getPathDataFromEl(el: SVGGeometryElement) {\n    let pathData: PathData = [];\n    let type = el.nodeName;\n    let atts, attNames, d, x, y, width, height, r, rx, ry, cx, cy, x1, x2, y1, y2;\n\n    // convert relative or absolute units \n    svgElUnitsToPixel(el)\n\n    const getAtts = (attNames) => {\n        atts = {}\n        attNames.forEach(att => {\n            const attr = el.getAttribute(att);\n            if (attr) {\n                atts[att] = +attr\n            }\n        })\n        return atts\n    }\n\n    switch (type) {\n        case 'path':\n            d = el.getAttribute(\"d\");\n            pathData = parsePathDataNormalized(d);\n            break;\n\n        case 'rect':\n            attNames = ['x', 'y', 'width', 'height', 'rx', 'ry'];\n            ({ x, y, width, height, rx, ry } = getAtts(attNames));\n\n\n            if (!rx && !ry) {\n                pathData = [\n                    { type: \"M\", values: [x, y] },\n                    { type: \"H\", values: [x + width] },\n                    { type: \"V\", values: [y + height] },\n                    { type: \"H\", values: [x] },\n                    { type: \"Z\", values: [] }\n                ];\n            } else {\n\n                if (rx > width / 2) {\n                    rx = width / 2;\n                }\n                if (ry > height / 2) {\n                    ry = height / 2;\n                }\n\n                pathData = [\n                    { type: \"M\", values: [x + rx, y] },\n                    { type: \"H\", values: [x + width - rx] },\n                    { type: \"A\", values: [rx, ry, 0, 0, 1, x + width, y + ry] },\n                    { type: \"V\", values: [y + height - ry] },\n                    { type: \"A\", values: [rx, ry, 0, 0, 1, x + width - rx, y + height] },\n                    { type: \"H\", values: [x + rx] },\n                    { type: \"A\", values: [rx, ry, 0, 0, 1, x, y + height - ry] },\n                    { type: \"V\", values: [y + ry] },\n                    { type: \"A\", values: [rx, ry, 0, 0, 1, x + rx, y] },\n                    { type: \"Z\", values: [] }\n                ];\n            }\n            break;\n\n        case 'circle':\n        case 'ellipse':\n\n            attNames = ['cx', 'cy', 'rx', 'ry', 'r'];\n            ({ cx, cy, r, rx, ry } = getAtts(attNames));\n\n            if (type === 'circle') {\n                r = r;\n                rx = r\n                ry = r\n            } else {\n                rx = rx ? rx : r;\n                ry = ry ? ry : r;\n            }\n\n            pathData = [\n                { type: \"M\", values: [cx + rx, cy] },\n                { type: \"A\", values: [rx, ry, 0, 1, 1, cx - rx, cy] },\n                { type: \"A\", values: [rx, ry, 0, 1, 1, cx + rx, cy] },\n            ];\n\n            break;\n        case 'line':\n            attNames = ['x1', 'y1', 'x2', 'y2'];\n            ({ x1, y1, x2, y2 } = getAtts(attNames));\n            pathData = [\n                { type: \"M\", values: [x1, y1] },\n                { type: \"L\", values: [x2, y2] }\n            ];\n            break;\n        case 'polygon':\n        case 'polyline':\n            const attr = el.getAttribute('points');\n            if (attr) {\n                let points = attr.replaceAll(',', ' ').split(' ').filter(Boolean)\n\n                for (let i = 0; i < points.length; i += 2) {\n                    pathData.push({\n                        type: (i === 0 ? \"M\" : \"L\"),\n                        values: [+points[i], +points[i + 1]]\n                    });\n                }\n                if (type === 'polygon') {\n                    pathData.push({\n                        type: \"Z\",\n                        values: []\n                    });\n                }\n            }\n\n            break;\n    }\n\n    return pathData;\n};\n","import { Matrix, PathData, PathElement, Point } from \"./type\";\n\n/**\n * scale pathData\n */\nexport function transformPathData(pathData: PathData, matrix: Matrix) {\n    // new pathdata\n    let pathDataTrans: PathData = [];\n\n    // normalize matrix input\n    matrix = normalizeMatrix(matrix);\n\n    let matrixStr = [matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f]\n        .map((val) => {\n            return +val.toFixed(1);\n        })\n        .join(\"\");\n\n    // no transform: quit\n    if (matrixStr === \"100100\") {\n        //console.log(\"no transform\");\n        return pathData;\n    }\n\n    pathData.forEach((com, i) => {\n        let { type, values } = com;\n        let typeRel = type.toLowerCase();\n        let comPrev = i > 0 ? pathData[i - 1] : pathData[i];\n        let comPrevValues = comPrev.values;\n        let comPrevValuesL = comPrevValues.length;\n        let p0 = {\n            x: comPrevValues[comPrevValuesL - 2],\n            y: comPrevValues[comPrevValuesL - 1]\n        };\n        let p = { x: values[values.length - 2], y: values[values.length - 1] };\n        let comT: PathElement = { type: type, values: [] };\n\n        switch (typeRel) {\n            case \"a\":\n                comT = transformArc(p0, values, matrix)\n                break;\n\n            default:\n                // all other point based commands\n                if (values.length) {\n                    for (let i = 0; i < values.length; i += 2) {\n                        let ptTrans = transformPoint(\n                            { x: com.values[i], y: com.values[i + 1] },\n                            matrix\n                        );\n                        comT.values[i] = ptTrans.x;\n                        comT.values[i + 1] = ptTrans.y;\n                    }\n                }\n        }\n\n        pathDataTrans.push(comT);\n    });\n    return pathDataTrans;\n}\n\n// transform point by 2d matrix\nfunction transformPoint(pt: Point, matrix: Matrix) {\n    let { a, b, c, d, e, f } = matrix;\n    let { x, y } = pt;\n    return { x: a * x + c * y + e, y: b * x + d * y + f };\n}\n\n//normalize matrix notations object, array or css matrix string\nfunction normalizeMatrix(matrix: Matrix | string | number[]) {\n    matrix =\n        typeof matrix === \"string\"\n            ? (matrix = matrix\n                .replace(/^matrix\\(|\\)$/g, \"\")\n                .split(\",\")\n                .map(Number))\n            : matrix;\n    return !Array.isArray(matrix)\n        ? {\n            a: matrix.a,\n            b: matrix.b,\n            c: matrix.c,\n            d: matrix.d,\n            e: matrix.e,\n            f: matrix.f\n        }\n        : {\n            a: matrix[0],\n            b: matrix[1],\n            c: matrix[2],\n            d: matrix[3],\n            e: matrix[4],\n            f: matrix[5]\n        };\n}\n\n\nfunction transformArc(p0: Point, values: number[], matrix: Matrix) {\n    let [rx, ry, angle, largeArc, sweep, x, y] = values;\n\n    /**\n    * parametrize arc command \n    * to get the actual arc params\n    */\n    let arcData = svgArcToCenterParam(\n        p0.x,\n        p0.y,\n        values[0],\n        values[1],\n        angle,\n        largeArc,\n        sweep,\n        x,\n        y\n    );\n    ({ rx, ry } = arcData);\n    let { a, b, c, d, e, f } = matrix;\n\n    let ellipsetr = transformEllipse(rx, ry, angle, matrix);\n    let p = transformPoint({ x: x, y: y }, matrix);\n\n\n    // adjust sweep if flipped\n    let denom = a ** 2 + b ** 2;\n    let scaleX = Math.sqrt(denom)\n    let scaleY = (a * d - c * b) / scaleX\n\n    let flipX = scaleX < 0 ? true : false;\n    let flipY = scaleY < 0 ? true : false;\n\n\n    // adjust sweep\n    if (flipX || flipY) {\n        sweep = sweep === 0 ? 1 : 0;\n    }\n\n    return {\n        type: 'A',\n        values: [\n            ellipsetr.rx,\n            ellipsetr.ry,\n            ellipsetr.ax,\n            largeArc,\n            sweep,\n            p.x,\n            p.y]\n    };\n}\n\n/**\n * Based on: https://github.com/fontello/svgpath/blob/master/lib/ellipse.js\n * and fork: https://github.com/kpym/SVGPathy/blob/master/lib/ellipse.js\n */\n\nfunction transformEllipse(rx: number, ry: number, ax: number, matrix: Matrix) {\n    const torad = Math.PI / 180;\n    const epsilon = 1e-7;\n\n    //normalize matrix object or array notations\n    matrix = !Array.isArray(matrix)\n        ? matrix\n        : {\n            a: matrix[0],\n            b: matrix[1],\n            c: matrix[2],\n            d: matrix[3],\n            e: matrix[4],\n            f: matrix[5]\n        };\n\n    // We consider the current ellipse as image of the unit circle\n    // by first scale(rx,ry) and then rotate(ax) ...\n    // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.\n    var c = Math.cos(ax * torad),\n        s = Math.sin(ax * torad);\n    var ma = [\n        rx * (matrix.a * c + matrix.c * s),\n        rx * (matrix.b * c + matrix.d * s),\n        ry * (-matrix.a * s + matrix.c * c),\n        ry * (-matrix.b * s + matrix.d * c)\n    ];\n\n    // ma * transpose(ma) = [ J L ]\n    //                      [ L K ]\n    // L is calculated later (if the image is not a circle)\n    var J = ma[0] * ma[0] + ma[2] * ma[2],\n        K = ma[1] * ma[1] + ma[3] * ma[3];\n\n    // the sqrt of the discriminant of the characteristic polynomial of ma * transpose(ma)\n    // this is also the geometric mean of the eigenvalues\n    var D = Math.sqrt(\n        ((ma[0] - ma[3]) * (ma[0] - ma[3]) + (ma[2] + ma[1]) * (ma[2] + ma[1])) *\n        ((ma[0] + ma[3]) * (ma[0] + ma[3]) + (ma[2] - ma[1]) * (ma[2] - ma[1]))\n    );\n\n    // the arithmetic mean of the eigenvalues\n    var JK = (J + K) / 2;\n\n    // check if the image is (almost) a circle\n    if (D <= epsilon) {\n        rx = ry = Math.sqrt(JK);\n        ax = 0;\n        return { rx: rx, ry: ry, ax: ax };\n    }\n\n    // check if ma * transpose(ma) is (almost) diagonal\n    if (Math.abs(D - Math.abs(J - K)) <= epsilon) {\n        rx = Math.sqrt(J);\n        ry = Math.sqrt(K);\n        ax = 0;\n        return { rx: rx, ry: ry, ax: ax };\n    }\n\n    // if it is not a circle, nor diagonal\n    var L = ma[0] * ma[1] + ma[2] * ma[3];\n\n    // {l1,l2} = the two eigen values of ma * transpose(ma)\n    var l1 = JK + D / 2,\n        l2 = JK - D / 2;\n\n    // the x - axis - rotation angle is the argument of the l1 - eigenvector\n    if (Math.abs(L) <= epsilon && Math.abs(l1 - K) <= epsilon) {\n        // if (ax == 90) => ax = 0 and exchange axes\n        ax = 0;\n        rx = Math.sqrt(l2);\n        ry = Math.sqrt(l1);\n        return { rx: rx, ry: ry, ax: ax };\n    }\n\n    ax =\n        Math.atan(Math.abs(L) > Math.abs(l1 - K) ? (l1 - J) / L : L / (l1 - K)) /\n        torad; // the angle in degree\n\n    // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90\n    if (ax >= 0) {\n        // if ax in [0,90]\n        rx = Math.sqrt(l1);\n        ry = Math.sqrt(l2);\n    } else {\n        // if ax in ]-90,0[ => exchange axes\n        ax += 90;\n        rx = Math.sqrt(l2);\n        ry = Math.sqrt(l1);\n    }\n\n    return { rx: rx, ry: ry, ax: ax };\n}\n\n\n/**\n* based on @cuixiping;\n* https://stackoverflow.com/questions/9017100/calculate-center-of-svg-arc/12329083#12329083\n*/\nfunction svgArcToCenterParam(p0x: number, p0y: number, rx: number, ry: number, angle: number, largeArc: number, sweep: number, px: number, py: number) {\n\n    const radian = (ux, uy, vx, vy) => {\n        let dot = ux * vx + uy * vy;\n        let mod = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));\n        let rad = Math.acos(dot / mod);\n        if (ux * vy - uy * vx < 0) {\n            rad = -rad;\n        }\n        return rad;\n    };\n\n    // degree to radian: if rx===ry the angle param has no effect\n    let phi = rx === ry ? 0 : (+angle * Math.PI) / 180;\n\n    let cx, cy, startAngle, deltaAngle, endAngle;\n    let PI = Math.PI;\n    let PIpx = PI * 2;\n\n    if (rx == 0 || ry == 0) {\n        // invalid arguments\n        throw Error(\"rx and ry can not be 0\");\n    }\n\n    // ensure rx and ry are positive\n    if (rx < 0 || ry < 0) {\n        [rx, ry] = [Math.abs(rx), Math.abs(ry)]\n    }\n\n    let s_phi = phi === 0 ? 0 : Math.sin(phi);\n    let c_phi = phi === 0 ? 1 : Math.cos(phi);\n\n    let hd_x = (p0x - px) / 2; // half diff of x\n    let hd_y = (p0y - py) / 2; // half diff of y\n    let hs_x = (p0x + px) / 2; // half sum of x\n    let hs_y = (p0y + py) / 2; // half sum of y\n\n    // F6.5.1\n    let p0x_ = c_phi * hd_x + s_phi * hd_y;\n    let p0y_ = c_phi * hd_y - s_phi * hd_x;\n\n    // F.6.6 Correction of out-of-range radii\n    //   Step 3: Ensure radii are large enough\n    let lambda = (p0x_ * p0x_) / (rx * rx) + (p0y_ * p0y_) / (ry * ry);\n\n    if (lambda > 1) {\n        rx = rx * Math.sqrt(lambda);\n        ry = ry * Math.sqrt(lambda);\n    }\n\n    let rxry = rx * ry;\n    let rxp0y_ = rx * p0y_;\n    let ryp0x_ = ry * p0x_;\n    let sum_of_sq = rxp0y_ * rxp0y_ + ryp0x_ * ryp0x_; // sum of square\n    if (!sum_of_sq) {\n        throw Error(\"start point can not be same as end point\");\n    }\n\n    let coe = Math.sqrt(Math.abs((rxry * rxry - sum_of_sq) / sum_of_sq));\n\n    if (largeArc == sweep) {\n        coe = -coe;\n    }\n    // F6.5.2\n    let cx_ = (coe * rxp0y_) / ry;\n    let cy_ = (-coe * ryp0x_) / rx;\n\n    // F6.5.3\n    cx = c_phi * cx_ - s_phi * cy_ + hs_x;\n    cy = s_phi * cx_ + c_phi * cy_ + hs_y;\n    let xcr1 = (p0x_ - cx_) / rx;\n    let xcr2 = (p0x_ + cx_) / rx;\n    let ycr1 = (p0y_ - cy_) / ry;\n    let ycr2 = (p0y_ + cy_) / ry;\n\n    // F6.5.5\n    startAngle = radian(1, 0, xcr1, ycr1);\n\n    // F6.5.6\n    deltaAngle = radian(xcr1, ycr1, -xcr2, -ycr2);\n\n    if (deltaAngle > PIpx) {\n        deltaAngle -= PIpx;\n    } else if (deltaAngle < 0) {\n        deltaAngle += PIpx;\n    }\n    if (sweep == 0) {\n        deltaAngle -= PIpx;\n    }\n    endAngle = startAngle + deltaAngle;\n    if (endAngle > PIpx) {\n        endAngle -= PIpx;\n    } else if (endAngle < 0) {\n        endAngle += PIpx;\n    }\n    let toDegFactor = 180 / PI;\n    let outputObj = {\n        cx: cx,\n        cy: cy,\n        rx: rx,\n        ry: ry,\n        startAngle_deg: startAngle * toDegFactor,\n        startAngle: startAngle,\n        deltaAngle_deg: deltaAngle * toDegFactor,\n        deltaAngle: deltaAngle,\n        endAngle_deg: endAngle * toDegFactor,\n        endAngle: endAngle,\n        clockwise: sweep == 1\n    };\n\n    return outputObj;\n}"],"mappings":"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","names":["index_exports","__export","flattenSVGTransformations","__toCommonJS","parsePathDataNormalized","d","pathData","cmdRegEx","commands","comLengths","offX","offY","lastX","lastY","c","com","type","typeRel","typeAbs","isRel","chunkSize","values","n","arcValues","i","value","largeArc","sweep","finalX","comN","hasMultiple","chunk","comChunks","typeImplicit","typeFirst","valuesL","valuesPrev","valuesPrevL","cp1X","cp1Y","cpN1X","cpN1Y","cp2X","cp2Y","pathDataArcToCubic","pathData","arcAccuracy","pathDataAbs","com","i","type","values","valuesPrev","valuesPrevL","p0","cubicArcs","arcToBezier","cubicArc","splitSegments","TAU","rx","ry","rotation","largeArcFlag","sweepFlag","x","y","phi","sinphi","cosphi","pxp","pyp","lambda","lambdaRt","rxsq","rysq","pxpsq","pypsq","radicant","centerxp","centeryp","centerx","centery","vx1","vy1","vx2","vy2","vectorAngle","ux","uy","vx","vy","dot","ang1","ang2","segments","pathDataArc","angle90","k","a","cos2","sin2","approxUnitArc","x1","y1","x2","y2","pt","pathDataToRelative","pathData","decimals","com","val","M","x","y","mx","my","i","type","values","typeRel","v","vLen","pathDataToShorthands","pathData","decimals","comShort","pathDataShorts","i","com","type","values","valuesL","comPrev","valuesPrev","valuesPrevL","x","y","cp1X","cp1Y","cp2X","cp2Y","prevX","prevY","val0R","cpN1XR","val1R","cpN1YR","cpN1X","cpN1Y","cpN2X","cpN2Y","prevXR","prevYR","val","convertPathData","pathData","options","arcsToCubic","toRelative","toShorthands","arcAccuracy","decimals","pathDataArcToCubic","pathDataToShorthands","pathDataToRelative","serializePathData","pathData","decimals","minify","d","val","i","com0","com","type","values","svgElUnitsToPixel","el","decimals","svg","translateUnitToPixel","value","dpi","unit","val","rat","widthString","width","heightString","height","vBString","vB","w","h","scaleX","scaleY","scalRoot","attsH","attsV","att","valAbs","scale","convertShapeToPath","el","decimals","pathData","getPathDataFromEl","path","setAttributes","attributes","exclude","key","attArr","attObj","att","d","serializePathData","type","atts","attNames","x","y","width","height","r","rx","ry","cx","cy","x1","x2","y1","y2","svgElUnitsToPixel","getAtts","attr","parsePathDataNormalized","points","i","transformPathData","pathData","matrix","pathDataTrans","normalizeMatrix","val","com","i","type","values","typeRel","comPrevValues","comPrevValuesL","p0","p","comT","transformArc","ptTrans","transformPoint","pt","a","b","c","d","e","f","x","y","rx","ry","angle","largeArc","sweep","svgArcToCenterParam","ellipsetr","transformEllipse","denom","scaleX","scaleY","flipX","flipY","ax","torad","epsilon","s","ma","J","K","D","JK","L","l1","l2","p0x","p0y","px","py","radian","ux","uy","vx","vy","dot","mod","rad","phi","cx","cy","startAngle","deltaAngle","endAngle","PI","PIpx","s_phi","c_phi","hd_x","hd_y","hs_x","hs_y","p0x_","p0y_","lambda","rxry","rxp0y_","ryp0x_","sum_of_sq","coe","cx_","cy_","xcr1","xcr2","ycr1","ycr2","toDegFactor","flattenSVGTransformations","svg","options","el","convertShapeToPath","reduceElementTransforms","g","arcsToCubic","arcAccuracy","minify","decimals","parent","matrix","b","c","d","e","f","val","isTransformed","transObj","qrDecomposeMatrix","scale","scaleStrokeWidth","pathData","parsePathDataNormalized","pathDataArcToCubic","transformPathData","convertPathData","dNew","serializePathData","styles","strokeWidth","precision","a","angle","denom","scaleX","scaleY","skewX","translateX","translateY","rotate","cssTransforms","svgTransforms","prop","unit","convert"]}